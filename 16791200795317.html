<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=0.8,minimum-scale=0.8, maximum-scale=0.8,user-scalable=no,viewport-fit=cover">
    <title>
      
    面试   (二) :基础篇/1 - 宋明的博客
    
    </title>
    

    
    
    <link href="atom.xml" rel="alternate" title="宋明的博客" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    
    <!-- 百度分析 -->
    
    
      <script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script>
    
    <script src="asset/app.js"></script>
</head>
  <body style="overflow-x: hidden;">
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="self" class="navbar-item " href="index.html">Home</a>
                
                <a target="_self" class="navbar-item " href="archives.html">Archives</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                      
                      
                      
                      
                      
                      
                      <a href="mailto: 1317345135@qq.com" target="_blank" title="email">
                        <span class="icon is-large has-text-grey-darker">
                          <svg class="svg-inline--fa fa-email fa-w-14 fa-lg" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1208" width="200" height="200"><path fill="currentColor" d="M935.335233 153.62202h-846.666656a84.666666 84.666666 0 0 0-84.666666 84.666666v550.333327a84.666666 84.666666 0 0 0 84.666666 84.666665h846.666656a84.666666 84.666666 0 0 0 84.666666-84.666665v-550.333327a84.666666 84.666666 0 0 0-84.666666-84.666666z m-27.293711 213.952665L557.558216 549.672927a94.993177 94.993177 0 0 1-87.065555 0.197555l-354.612218-182.202664a42.333333 42.333333 0 0 1 38.698311-75.308177l354.606573 182.202664a10.196689 10.196689 0 0 0 9.341556-0.022577l350.477662-182.089776a42.333333 42.333333 0 1 1 39.034155 75.127555z" fill="#2c2c2c" p-id="1209"></path></svg>
                        </span>
                      </a>
                      
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                        <span class="icon is-large has-text-black-bis">
                          <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                        </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
</section>
<section class="ct-body">
  <div class="container">
    <div class="columns is-variable bd-klmn-columns is-4">
      <div class="column is-two-thirds">
        <div class="post-body single-content">      
          <div class="card-image">
            <figure class="random-img">
            </figure>
          </div>
          <h1 class="title">
            面试   (二) :基础篇/1   
          </h1>
           
          <div class="media">
            
            <figure class="media-left">
              <p class="image is-48x48">
                
                  <img class="is-rounded" src="">
              </p>
            </figure>
            
            <div class="media-content">
              <div class="content">
                <p style="line-height: 30px; font-size: 12px;">
                  
                  <a href="http://apolla.cc">宋明</a>
                  &nbsp;&nbsp;&nbsp;<span style="color: #ccc;">|</span>&nbsp;&nbsp;&nbsp;
                  
                  <span class="date"><i class="fa fa-calendar-check-o" aria-hidden="true"></i>&nbsp;2023/03/18</span>
                  
                  <span class="tran-posted-in">posted in</span>&nbsp; 
                  
                  
                    <span class="posted-in"><a href='%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8.html'><i class="fa fa-folder" aria-hidden="true"></i>&nbsp;&nbsp;葵花宝典</a></span>
                       
                  

                  

                  
                  
                </p>
              </div>
            </div>
          </div>
        </div>
        <article class="markdown-body single-content">
          <p>2015年11月25日 星期三<br />
10:05<br />
category和extension的区别<br />
• category：分类有名字，类扩展没i有分类名字，是一种特殊的分类<br />
• extension：分类只能扩展方法（属性仅仅是声明，并没真正实现），类扩展可以扩展属性、成员变量和方法</p>
<p>define和const常量有什么区别?<br />
• define在预处理阶段进行替换，const常量在编译阶段使用<br />
•宏不做类型检查，仅仅进行替换，const常量有数据类型，会执行类型检查<br />
• define不能调试，const常量可以调试<br />
• define定义的常量在替换后运行过程中会不断地占用内存，而const定义的常量存储在数据段只有一份copy，效率更高<br />
• define可以定义一些简单的函数，const不可以</p>
<p>block和weak修饰符的区别？<br />
•__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，也可以修饰基本数据类型<br />
•__weak只能在ARC模式下使用，只能修饰对象（NSString），不能修饰基本数据类型<br />
• block修饰的对象可以在block中被重新赋值，weak修饰的对象不可以</p>
<p>static关键字的作用<br />
•函数（方法）体内static变量的作用范围为该函数体，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值；<br />
•在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问；<br />
•在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明 它的模块内；<br />
•在类中的static成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；<br />
•在类中的static成员函数属于整个类所拥有，这个函数不接收this指针，因而只能访问类的static成员变量</p>
<p>堆和栈的区别<br />
•从管理方式来讲<br />
○对于栈来讲，是由编译器自动管理，无需我们手工控制；<br />
○对于堆来说，释放工作由程序员控制，容易产生内存泄露(memory leak)<br />
•从申请大小大小方面讲<br />
○栈空间比较小<br />
○堆控件比较大<br />
•从数据存储方面来讲<br />
○栈空间中一般存储基本类型，对象的地址<br />
○堆空间一般存放对象本身，block的copy等</p>
<p>风格纠错题<br />
•修改后的代码</p>
<p>typedef NS_ENUM(NSInteger, CYLSex)<br />
{<br />
CYLSexMan,<br />
CYLSexWoman<br />
};<br />
@interface CYLUser : NSObject<NSCopying><br />
@property(nonatomic,copy,readonly) NSString *name;<br />
@property(nonatomic,assign,readonly) NSUInteger age;<br />
@property(nonatomic,assign,readwrite) CYLSex sex;</p>
<ul>
<li>(instancetype)initWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;</li>
<li>(instancetype)initWithName:(NSString *)name age:(NSUInteger)age;</li>
</ul>
<ul>
<li>(instancetype)userWithName:(NSString *)name age:(NSUInteger)age sex:(CYLSex)sex;<br />
@end<br />
•<a href="https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01">https://github.com/ChenYilong/iOSInterviewQuestions/blob/master/01</a></li>
</ul>
<p>Objective-C使用什么机制管理对象内存？<br />
• MRC手动引用计数<br />
• ARC自动引用计数,现在通常ARC<br />
•通过retainCount的机制来决定对象是否需要释放。 每次runloop的时候，都会检查对象的retainCount，如果retainCount为0，说明该对象没有地方需要继续使用了，可以释放掉了</p>
<p>ARC通过什么方式帮助开发者管理内存？<br />
•通过编译器在编译的时候,插入类似内存管理的代码</p>
<p>ARC是为了解决什么问题诞生的？<br />
•首先解释ARC: automatic reference counting自动引用计数<br />
•了解MRC的缺点<br />
○在MRC时代当我们要释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了<br />
○释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针只能释放一次(MRC下即谁创建，谁释放，避免重复释放)<br />
○模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁去释放<br />
○多线程操作时，不确定哪个线程最后使用完毕<br />
•综上所述，MRC有诸多缺点，很容易造成内存泄露和坏内存的问题，这时苹果为尽量解决这个问题，从而诞生了ARC</p>
<p>ARC下还会存在内存泄露吗？<br />
•循环引用会导致内存泄露<br />
• Objective-C对象与CoreFoundation对象进行桥接的时候如果管理不当也会造成内存泄露<br />
• CoreFoundation中的对象不受ARC管理，需要开发者手动释放</p>
<p>什么情况使用weak关键字，相比assign有什么不同？<br />
•首先明白什么情况使用weak关键字？<br />
○在ARC中,在有可能出现循环引用的时候,往往要通过让其中一端使用weak来解决,比如:delegate代理属性，代理属性也可使用assign<br />
○自身已经对它进行一次强引用,没有必要再强引用一次,此时也会使用weak,自定义IBOutlet控件属性一般也使用weak；当然，也可以使用strong，但是建议使用weak<br />
• weak和assign的不同点<br />
○ weak策略在属性所指的对象遭到摧毁时，系统会将weak修饰的属性对象的指针指向nil，在OC给nil发消息是不会有什么问题的；如果使用assign策略在属性所指的对象遭到摧毁时，属性对象指针还指向原来的对象，由于对象已经被销毁，这时候就产生了野指针，如果这时候在给此对象发送消息，很容造成程序奔溃<br />
○ assigin可以用于修饰非OC对象,而weak必须用于OC对象</p>
<p>@property的本质是什么？<br />
•@property其实就是在编译阶段由编译器自动帮我们生成ivar成员变量，getter方法，setter方法<br />
ivar、getter、setter是如何生成并添加到这个类中的？<br />
•使用“自动合成”( autosynthesis)<br />
•这个过程由编译器在编译阶段执行自动合成，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码<br />
•除了生成getter、setter方法之外，编译器还要自动向类中添加成员变量（在属性名前面加下划线，以此作为实例变量的名字）<br />
•为了搞清属性是怎么实现的,反编译相关的代码,他大致生成了五个东西</p>
<p>该属性的“偏移量” (offset)，这个偏移量是“硬编码” (hardcode)，表示该变量距离存放对象的内存区域的起始地址有多远<br />
OBJC_IVAR_\(类名\)属性名称</p>
<p>方法对应的实现函数<br />
setter与getter</p>
<p>成员变量列表<br />
ivar_list</p>
<p>方法列表<br />
method_list</p>
<p>属性列表<br />
prop_list<br />
○每次增加一个属性，系统都会在ivar_list中添加一个成员变量的描述<br />
○在method_list中增加setter与getter方法的描述<br />
○在prop_list中增加一个属性的描述<br />
○计算该属性在对象中的偏移量<br />
○然后给出setter与getter方法对应的实现,在setter方法中从偏移量的位置开始赋值,在getter方法中从偏移量开始取值,为了能够读取正确字节数,系统对象偏移量的指针类型进行了类型强转<br />
@protocol和category中如何使用@property<br />
•在protocol中使用property只会生成setter和getter方法声明,我们使用属性的目的,是希望遵守我协议的对象能实现该属性<br />
• category使用@property也是只会生成setter和getter方法声明,如果我们真的需要给category增加属性的实现,需要借助于运行时的两个函数</p>
<p>objc_setAssociatedObject<br />
objc_getAssociatedObject<br />
@property后面可以有哪些修饰符？<br />
•原子性---nonatomic特质<br />
○如果不写默认情况为atomic（系统会自动加上同步锁，影响性能）<br />
○在iOS开发中尽量指定为nonatomic，这样有助于提高程序的性能<br />
•读/写权限---readwrite(读写)、readooly (只读)<br />
•内存管理语义---assign、strong、weak、unsafe_unretained、copy<br />
•方法名---getter=、setter=</p>
<p>@property (nonatomic, getter=isOn) BOOL on;<br />
setter=<name>这种不常用，也<strong>不推荐</strong>使用。故不在这里给出写法<br />
•不常用的：nonnull,null_resettable,nullable<br />
使用atomic一定是线程安全的吗？<br />
•不是，atomic的本意是指属性的存取方法是线程安全的，并不保证整个对象是线程安全的。<br />
•举例：声明一个NSMutableArray的原子属性stuff，此时self.stuff和self.stuff = othersulf都是线程安全的。但是，使用[self.stuff objectAtIndex:index]就不是线程安全的，需要用互斥锁来保证线程安全性</p>
<p>@synthesize和@dynamic分别有什么作用<br />
•@property有两个对应的词，一个是@synthesize，一个是@dynamic。如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;<br />
•@synthesize的语义是如果你没有手动实现setter方法和getter方法，那么编译器会自动为你加上这两个方法<br />
•@dynamic告诉编译器：属性的setter与getter方法由用户自己实现，不自动生成（当然对于readonly的属性只需提供getter即可）<br />
○假如一个属性被声明为@dynamicvar，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到instance.var = someVar，由于缺setter方法会导致程序崩溃；或者当运行到someVar = instance.var时，由于缺getter方法同样会导致崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定<br />
ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？<br />
•基本数据：atomic,readwrite,assign<br />
•普通的OC对象：atomic,readwrite,strong<br />
@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？<br />
•先回答第二个问题：不会<br />
•@synthesize合成成员变量的规则，有以下几点：<br />
○如果指定了成员变量的名称,会生成一个指定的名称的成员变量<br />
○如果这个成员已经存在了就不再生成了<br />
○如果指定@synthesizefoo;就会生成一个名称为foo的成员变量，也就是说：会自动生成一个属性同名的成员变量</p>
<p>@interface XMGPerson : NSObject</p>
<p>@property(nonatomic,assign)intage;</p>
<p>@end</p>
<p>@implementationXMGPerson</p>
<p>不加这语句默认生成的成员变量名为_age<br />
如果加上这一句就会生成一个跟属性名同名的成员变量<br />
@synthesizeage;</p>
<p>@end<br />
○如果是@synthesizefoo = _foo;就不会生成成员变量了<br />
在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？<br />
•首先的搞清楚什么情况下不会autosynthesis（自动合成）<br />
○同时重写了setter和getter时<br />
○重写了只读属性的getter时<br />
○使用了@dynamic时<br />
○在@protocol中定义的所有属性<br />
○在category中定义的所有属性<br />
○重载的属性，当你在子类中重载了父类中的属性，必须  使用@synthesize来手动合成ivar<br />
•应用场景<br />
○当你同时重写了setter和getter时，系统就不会生成ivar）。这时候有两种选择<br />
§手动创建ivar<br />
§使用@synthesizefoo = _foo;，关联@property与ivar<br />
○可以用来修改成员变量名，一般不建议这么做，建议使用系统自动生成的成员变量<br />
怎么用copy关键字？<br />
• NSString、NSArray、NSDictionary等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，为确保对象中的属性值不会无意间变动，应该在设置新属性值时拷贝一份，保护其封装性<br />
• block也经常使用copy关键字<br />
○ block使用copy是从MRC遗留下来的“传统”,在MRC中,方法内部的block是在栈区的,使用copy可以把它放到堆区.<br />
○在ARC中写不写都行：对于block使用copy还是strong效果是一样的，但是建议写上copy，因为这样显示告知调用者“编译器会自动对block进行了copy操作”<br />
用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？<br />
•因为父类指针可以指向子类对象,使用copy的目的是为了让本对象的属性不受外界影响,使用copy无论给我传入是一个可变对象还是不可对象,我本身持有的就是一个不可变的副本.<br />
•如果我们使用是strong,那么这个属性就有可能指向一个可变对象,如果这个可变对象在外部被修改了,那么会影响该属性.<br />
复制详解<br />
•浅复制(shallow copy)：在浅复制操作时，对于被复制对象的每一层都是指针复制。<br />
•深复制(one-level-deep  copy)：在深复制操作时，对于被复制对象，至少有一层是深复制。<br />
•完全复制(real-deep  copy)：在完全复制操作时，对于被复制对象的每一层都是对象复制。<br />
•非集合类对象的copy与mutableCopy</p>
<p>[不可变对象copy]  浅复制<br />
[不可变对象mutableCopy]  深复制<br />
[可变对象copy]  深复制<br />
[可变对象mutableCopy]深复制<br />
•集合类对象的copy与mutableCopy</p>
<p>[不可变对象copy]  浅复制<br />
[不可变对象mutableCopy]单层深复制<br />
[可变对象copy]  单层深复制<br />
[可变对象mutableCopy]单层深复制<br />
•这里需要注意的是集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制<br />
这个写法会出什么问题：@property(copy) NSMutableArray *array;<br />
•因为copy策略拷贝出来的是一个不可变对象，然而却把它当成可变对象使用，很容易造成程序奔溃<br />
•这里还有一个问题，该属性使用了同步锁，会在创建时生成一些额外的代码用于帮助编写多线程程序，这会带来性能问题，通过声明nonatomic可以节省这些虽然很小但是不必要额外开销，在iOS开发中应该使用nonatomic替代atomic<br />
如何让自定义类可以用copy修饰符？如何重写带copy关键字的setter？<br />
•若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。如果自定义的对象分为可变版本与不可变版本，那么就要同时实现NSCopyiog与NSMutableCopying协议，不过一般没什么必要，实现NSCopying协议就够了</p>
<p>实现不可变版本拷贝</p>
<ul>
<li>(id)copyWithZone:(NSZone *)zone;<br />
实现可变版本拷贝</li>
<li>(id)mutableCopyWithZone:(NSZone *)zone;<br />
重写带copy关键字的setter</li>
<li>(void)setName:(NSString *)name<br />
{<br />
_name = [name copy];<br />
}</li>
</ul>
<p>+(void)load; +(void)initialize;有什么用处？<br />
• +(void)load;<br />
○当类对象被引入项目时, runtime会向每一个类对象发送load消息<br />
○ load方法会在每一个类甚至分类被引入时仅调用一次,调用的顺序：父类优先于子类,子类优先于分类<br />
○由于load方法会在类被import时调用一次,而这时往往是改变类的行为的最佳时机，在这里可以使用例如method swizlling来修改原有的方法<br />
○ load方法不会被类自动继承<br />
• +(void)initialize;<br />
○也是在第一次使用这个类的时候会调用这个方法，也就是说initialize也是懒加载<br />
•总结：<br />
○在Objective-C中，runtime会自动调用每个类的这两个方法<br />
○ +load会在类初始加载时调用<br />
○ +initialize会在第一次调用类的类方法或实例方法之前被调用<br />
○这两个方法是可选的，且只有在实现了它们时才会被调用<br />
○两者的共同点：两个方法都只会被调用一次</p>
<p>Foundation对象与Core Foundation对象有什么区别<br />
• Foundation框架是使用OC实现的，Core Foundation是使用C实现的<br />
• Foundation对象 和Core Foundation对象间的转换：俗称桥接<br />
○ ARC环境桥接关键字：</p>
<p>可用于Foundation对象 和Core Foundation对象间的转换<br />
__bridge</p>
<p>用于Foundation对象 转成Core Foundation对象<br />
__bridge_retained</p>
<p>Core Foundation对象 转成Foundation对象<br />
__bridge_transfer<br />
Foundation对象 转成Core Foundation对象<br />
□使用__bridge桥接<br />
®如果使用__bridge桥接,它仅仅是将strOC的地址给了strC,并没有转移对象的所有权，也就是说,如果使用__bridge桥接,那么如果strOC释放了,strC也不能用了<br />
®注意:在ARC条件下,如果是使用__bridge桥接,那么strC可以不用主动释放,因为ARC会自动管理strOC和strC<br />
□<br />
NSString *strOC1 = [NSString stringWithFormat:@&quot;abcdefg&quot;];<br />
CFStringRef strC1 = (__bridge CFStringRef)strOC1;<br />
NSLog(@&quot;%@ %@&quot;, strOC1, strC1);<br />
□使用__bridge_retained桥接<br />
®如果使用__bridge_retained桥接,它会将对象的所有权转移给strC,也就是说,  即便strOC被释放了, strC也可以使用<br />
®注意:在ARC条件下,如果是使用__bridge_retained桥接,那么strC必须自己手动释放,因为桥接的时候已经将对象的所有权转移给了strC,而C语言的东西不是不归ARC管理的<br />
□<br />
NSString *strOC2 = [NSString stringWithFormat:@&quot;abcdefg&quot;];<br />
CFStringRef strC2 = (__bridge_retained CFStringRef)strOC2;<br />
CFStringRef strC2 = CFBridgingRetain(strOC2);//这一句,就等同于上一句<br />
CFRelease(strC2);<br />
§ Core Foundation对象 转成Foundation对象<br />
□使用__bridge桥接<br />
®如果使用__bridge桥接,它仅仅是将strC的地址给了strOC,并没有转移对象的所有权<br />
®也就是说如果使用__bridge桥接,那么如果strC释放了,strOC也不能用了<br />
□<br />
CFStringRef strC3 = CFStringCreateWithCString(CFAllocatorGetDefault(), &quot;12345678&quot;, kCFStringEncodingASCII);<br />
NSString *strOC3 = (__bridge NSString *)strC3;<br />
CFRelease(strC3);<br />
□使用__bridge_transfer桥接<br />
®如果使用__bridge_transfer桥接,它会将对象的所有权转移给strOC,也就是说,  即便strC被释放了, strOC也可以使用<br />
®如果使用__bridge_transfer桥接,他会自动释放strC,也就是以后我们不用手动释放strC<br />
□<br />
CFStringRef strC4 = CFStringCreateWithCString(CFAllocatorGetDefault(), &quot;12345678&quot;, kCFStringEncodingASCII);<br />
NSString *strOC = (__bridge_transfer NSString *)strC;<br />
NSString *strOC4 = CFBridgingRelease(strC4);这一句,就等同于上一句<br />
○ MRC环境：直接强转</p>
<p>-(void)bridgeInMRC<br />
{<br />
将Foundation对象转换为Core Foundation对象，直接强制类型转换即可<br />
NSString *strOC1 = [NSString stringWithFormat:@&quot;xxxxxx&quot;];<br />
CFStringRef strC1 = (CFStringRef)strOC1;<br />
NSLog(@&quot;%@ %@&quot;, strOC1, strC1);<br />
[strOC1 release];<br />
CFRelease(strC1);</p>
<p>将Core Foundation对象转换为Foundation对象，直接强制类型转换即可<br />
CFStringRef strC2 = CFStringCreateWithCString(CFAllocatorGetDefault(), &quot;12345678&quot;, kCFStringEncodingASCII);<br />
NSString *strOC2 = (NSString *)strC2;<br />
NSLog(@&quot;%@ %@&quot;, strOC2, strC2);<br />
[strOC2 release];<br />
CFRelease(strC2);<br />
}<br />
addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？</p>
<p>/**</p>
<ol>
<li>self.person：要监听的对象<br />
2.参数说明<br />
1&gt;观察者，负责处理监听事件的对象<br />
2&gt;要监听的属性<br />
3&gt;观察的选项（观察新、旧值，也可以都观察）<br />
4&gt;上下文，用于传递数据，可以利用上下文区分不同的监听<br />
<em>/<br />
[self.person addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:@&quot;Person Name&quot;];<br />
/</em>*</li>
</ol>
<ul>
<li>当监控的某个属性的值改变了就会调用</li>
<li></li>
<li>@param keyPath监听的属性名</li>
<li>@param object  属性所属的对象</li>
<li>@param change  属性的修改情况（属性原来的值、属性最新的值）</li>
<li>@param context传递的上下文数据，与监听的时候传递的一致，可以利用上下文区分不同的监听<br />
*/</li>
</ul>
<ul>
<li>(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context<br />
{<br />
NSLog(@&quot;%@对象的%@属性改变了：%@&quot;, object, keyPath, change);<br />
}</li>
</ul>
<p>KVO内部实现原理<br />
• KVO是基于runtime机制实现的<br />
•当某个类的属性对象第一次被观察时，系统就会在运行期动态地创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter方法。派生类在被重写的setter方法内实现真正的通知机制<br />
•如果原类为Person，那么生成的派生类名为NSKVONotifying_Person<br />
•每个类对象中都有一个isa指针指向当前类，当一个类对象的第一次被观察，那么系统会偷偷将isa指针指向动态生成的派生类，从而在给被监控属性赋值时执行的是派生类的setter方法<br />
•键值观察通知依赖于NSObject的两个方法: willChangeValueForKey:和didChangevlueForKey:；在一个被观察属性发生改变之前，willChangeValueForKey:一定会被调用，这就 会记录旧的值。而当改变发生后，didChangeValueForKey:会被调用，继而observeValueForKey:ofObject:change:context:也会被调用。<br />
•补充：KVO的这套实现机制中苹果还偷偷重写了class方法，让我们误认为还是使用的当前类，从而达到隐藏生成的派生类</p>
<p>如何手动触发一个value的KVO<br />
•自动触发的场景：在注册KVO之前设置一个初始值，注册之后，设置一个不一样的值，就可以触发了<br />
•想知道如何手动触发，必须知道自动触发KVO的原理，见上面的描述<br />
•手动触发演示</p>
<p>@property(nonatomic,strong) NSDate *now;</p>
<ul>
<li>(void)viewDidLoad<br />
{<br />
[super viewDidLoad];<br />
“手动触发self.now的KVO”，必写。<br />
[self willChangeValueForKey:@&quot;now&quot;];<br />
“手动触发self.now的KVO”，必写。<br />
[self didChangeValueForKey:@&quot;now&quot;];<br />
}<br />
若一个类有实例变量NSString *_foo，调用setValue:forKey:时，是以foo还是_foo作为key？<br />
•都可以</li>
</ul>
<p>KVC的keyPath中的集合运算符如何使用？<br />
•必须用在集合对象上或普通对象的集合属性上<br />
•简单集合运算符有@avg，@count，@max，@min，@sum<br />
•格式@&quot;@sum.age&quot;或@&quot;集合属性<a href="mailto:.@max.age">.@max.age</a>&quot;？？？</p>
<p>KVC和KVO的keyPath一定是属性么？<br />
•可以是成员变量<br />
如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？<br />
•如何自己动手实现KVO<br />
apple用什么方式实现对一个对象的KVO？<br />
•此题就是问KVO的实现原理</p>
<p>已使用 Microsoft OneNote 2016 创建。</p>

        </article>
        <div class="comments-wrap">
          <div class="share-comments">
            
            <script src="https://utteranc.es/client.js"
                    repo="Apolla/gtalk"
                    issue-term="title"
                    theme="github-dark"
                    crossorigin="anonymous"
                    id="github-comment"
                    async>
            </script>
             
            

            

            
          </div>
        </div><!-- end comments wrap -->
      </div>
      <div class="column">
         <div class="card">
  <header class="card-header">
    <p class="card-header-title">
      <i class="fa fa-commenting" aria-hidden="true"></i>&nbsp;&nbsp;
      <span class="tran-notice">Notice</span> 
    </p>
  </header>
  <div class="card-content site-notice">
    <div class="content"> 
        
    </div>
  </div>                    
</div>
<div class="card">
  <header class="card-header">
    <p class="card-header-title">
      <i class="fa fa-folder-open" aria-hidden="true"></i>&nbsp;&nbsp;
      <span class="tran-site-categories">Categories</span> 
    </p>
  </header>
  <div class="card-content site-categories">
    <div class="content"> 
      <ul>
      
        <li><a href="%E7%BB%84%E4%BB%B6%E5%8C%96.html">组件化</a>
          
          
          
        </li> 
      
        <li><a href="%E7%A2%8E%E7%89%87%E8%8A%9D%E5%A3%AB%E6%94%B6%E8%97%8F.html">碎片芝士收藏</a>
          
          
          
        </li> 
      
        <li><a href="%E7%9B%B4%E6%92%AD.html">直播</a>
          
          
          
        </li> 
      
        <li><a href="coreBluetooth.html">coreBluetooth</a>
          
          
          
        </li> 
      
        <li><a href="%E4%B8%80%E9%98%85%E9%98%85%E8%AF%BB.html">一阅阅读</a>
          
          
          
        </li> 
      
        <li><a href="SwiftUI.html">SwiftUI</a>
          
          
          
        </li> 
      
        <li><a href="%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8.html">葵花宝典</a>
          
          
          
        </li> 
      
      </ul>
    </div>
  </div>                    
</div>
<div class="card">
  <header class="card-header">
    <p class="card-header-title">
      <i class="fa fa-tags" aria-hidden="true"></i>&nbsp;&nbsp;
      <span class="tran-site-tags">Tags</span> 
    </p>
  </header>
  <div class="card-content site-tags">
    <div class="content">
      <div class="tags">
      
      </div>
    </div>
  </div>
</div>

      </div>
    </div><!-- end columns -->
  </div><!-- end container -->
</section>



    <footer class="footer">
    <div id="plt"></div>
    <div class="content has-text-centered">
      <p>
        Copyright &copy; 2019
        <span id="tran-author" class="tran-author">Author: </span><a target="_blank" href="http://apolla.cc">宋明</a>,&nbsp; 
        <span class="tran-theme">Theme: </span><a target="_blank" href="https://github.com/AlanAlbert/atheme">Atheme</a> (Based on BulmaCSS).
      </p>
    </div>
  </footer>



<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

  













<script type="text/javascript">
  var imgApi = "https://source.unsplash.com/random/1024x";
  var imgContainers = document.getElementsByClassName('random-img');
  for (var i = 0; i <= imgContainers.length - 1; i++) {
    // https://picsum.photos/1024/
    var img = document.createElement('img');
    img.src = imgApi + (400 + i);
    imgContainers[i].appendChild(img);
  }
</script>


<script type="text/javascript">
  
  
    var modelJson = "asset/plt/model.json";
    var pluginRootPath = 'asset/plt';
    var pluginModelPath = 'asset/plt';
  

  var config = {
    pluginRootPath: pluginRootPath,
    pluginJsPath: "lib/",
    pluginModelPath: pluginModelPath,
    tagMode:false,
    debug:false,
    model: {
      jsonPath: modelJson,  // xxx.model.json 的路径
    },
    display: {
      width: 325,           // canvas的宽度
      height: 300,          // canvas的高度
      position: 'right',    // 显示位置：左或右
      hOffset: -75,         // canvas水平偏移
      vOffset: 0,           // canvas垂直偏移
    },
    dialog:{
      enable: true
    },
    mobile: {
      show: false,         // 是否在移动设备上显示
    },
    react: {
      opacity: 1,         // 透明度
    },
    log: false,
  };
  L2Dwidget.init(config);
</script>


  
    




  </body>
</html>
