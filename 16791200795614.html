<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=0.8,minimum-scale=0.8, maximum-scale=0.8,user-scalable=no,viewport-fit=cover">
    <title>
      
    面试   (四) : UI篇 - 宋明的博客
    
    </title>
    

    
    
    <link href="atom.xml" rel="alternate" title="宋明的博客" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    
    <!-- 百度分析 -->
    
    
      <script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script>
    
    <script src="asset/app.js"></script>
</head>
  <body style="overflow-x: hidden;">
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="self" class="navbar-item " href="index.html">Home</a>
                
                <a target="_self" class="navbar-item " href="archives.html">Archives</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                      
                      
                      
                      
                      
                      
                      <a href="mailto: 1317345135@qq.com" target="_blank" title="email">
                        <span class="icon is-large has-text-grey-darker">
                          <svg class="svg-inline--fa fa-email fa-w-14 fa-lg" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1208" width="200" height="200"><path fill="currentColor" d="M935.335233 153.62202h-846.666656a84.666666 84.666666 0 0 0-84.666666 84.666666v550.333327a84.666666 84.666666 0 0 0 84.666666 84.666665h846.666656a84.666666 84.666666 0 0 0 84.666666-84.666665v-550.333327a84.666666 84.666666 0 0 0-84.666666-84.666666z m-27.293711 213.952665L557.558216 549.672927a94.993177 94.993177 0 0 1-87.065555 0.197555l-354.612218-182.202664a42.333333 42.333333 0 0 1 38.698311-75.308177l354.606573 182.202664a10.196689 10.196689 0 0 0 9.341556-0.022577l350.477662-182.089776a42.333333 42.333333 0 1 1 39.034155 75.127555z" fill="#2c2c2c" p-id="1209"></path></svg>
                        </span>
                      </a>
                      
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                        <span class="icon is-large has-text-black-bis">
                          <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                        </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
</section>
<section class="ct-body">
  <div class="container">
    <div class="columns is-variable bd-klmn-columns is-4">
      <div class="column is-two-thirds">
        <div class="post-body single-content">      
          <div class="card-image">
            <figure class="random-img">
            </figure>
          </div>
          <h1 class="title">
            面试   (四) : UI篇   
          </h1>
           
          <div class="media">
            
            <figure class="media-left">
              <p class="image is-48x48">
                
                  <img class="is-rounded" src="">
              </p>
            </figure>
            
            <div class="media-content">
              <div class="content">
                <p style="line-height: 30px; font-size: 12px;">
                  
                  <a href="http://apolla.cc">宋明</a>
                  &nbsp;&nbsp;&nbsp;<span style="color: #ccc;">|</span>&nbsp;&nbsp;&nbsp;
                  
                  <span class="date"><i class="fa fa-calendar-check-o" aria-hidden="true"></i>&nbsp;2023/03/18</span>
                  
                  <span class="tran-posted-in">posted in</span>&nbsp; 
                  
                  
                    <span class="posted-in"><a href='%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8.html'><i class="fa fa-folder" aria-hidden="true"></i>&nbsp;&nbsp;葵花宝典</a></span>
                       
                  

                  

                  
                  
                </p>
              </div>
            </div>
          </div>
        </div>
        <article class="markdown-body single-content">
          <p>2015年11月25日 星期三<br />
10:06</p>
<p>Size Classes具体使用<br />
•对屏幕进行分类<br />
UIView和CALayer是什么关系?<br />
• UIView显示在屏幕上归功于CALayer，通过调用drawRect方法来渲染自身的内容，调节CALayer属性可以调整UIView的外观，UIView继承自UIResponder，比起CALayer可以响应用户事件，Xcode6之后可以方便的通过视图调试功能查看图层之间的关系<br />
• UIView是iOS系统中界面元素的基础，所有的界面元素都继承自它。它内部是由Core Animation来实现的，它真正的绘图部分，是由一个叫CALayer(Core Animation Layer)的类来管理。UIView本身，更像是一个CALayer的管理器，访问它的跟绘图和坐标有关的属性，如frame，bounds等，实际上内部都是访问它所在CALayer的相关属性<br />
• UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示，如：</p>
<ul>
<li>(class) layerClass {<br />
//使某个UIView的子类使用GL来进行绘制<br />
return ([CAEAGLLayer class]);<br />
}<br />
• UIView的CALayer类似UIView的子View树形结构，也可以向它的layer上添加子layer，来完成某些特殊的显示。例如下面的代码会在目标View上敷上一层黑色的透明薄膜。</li>
</ul>
<p>grayCover = [[CALayer alloc]init];<br />
grayCover.backgroudColor = [[UIColor blackColor]colorWithAlphaComponent:0.2].CGColor;<br />
[self.layer addSubLayer:grayCover];<br />
•补充部分，这部分有深度了，大致了解一下吧，UIView的layer树形在系统内部被系统维护着三份copy<br />
○逻辑树，就是代码里可以操纵的，例如更改layer的属性等等就在这一份<br />
○动画树，这是一个中间层，系统正是在这一层上更改属性，进行各种渲染操作<br />
○显示树，这棵树的内容是当前正被显示在屏幕上的内容<br />
○这三棵树的逻辑结构都是一样的，区别只有各自的属性<br />
loadView的作用？<br />
• loadView用来自定义view，只要实现了这个方法，其他通过xib或storyboard创建的view都不会被加载<br />
看懂控制器view创建的这个图就行</p>
<p>#IBOutlet连出来的视图属性为什么可以被设置成weak?<br />
•因为父控件的subViews数组已经对它有一个强引用<br />
IB中User Defined Runtime Attributes如何使用？<br />
• User Defined Runtime Attributes是一个不被看重但功能非常强大的的特性，它能够通过KVC的方式配置一些你在interface builder中不能配置的属性<br />
•当你希望在IB中作尽可能多得事情，这个特性能够帮助你编写更加轻量级的viewcontroller<br />
#沙盒目录结构是怎样的？各自用于那些场景？<br />
• Application：存放程序源文件，上架前经过数字签名，上架后不可修改<br />
• Documents：常用目录，iCloud备份目录，存放数据<br />
• Library<br />
○ Caches：存放体积大又不需要备份的数据<br />
○ Preference：设置目录，iCloud会备份设置信息<br />
• tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能<br />
#pushViewController和presentViewController有什么区别<br />
•两者都是在多个试图控制器间跳转的函数<br />
• presentViewController提供的是一个模态视图控制器(modal)<br />
• pushViewController提供一个栈控制器数组，push/pop<br />
#请简述UITableView的复用机制<br />
•每次创建cell的时候通过dequeueReusableCellWithIdentifier:方法创建cell，它先到缓存池中找指定标识的cell，如果没有就直接返回nil<br />
•如果没有找到指定标识的cell，那么会通过initWithStyle:reuseIdentifier:创建一个cell<br />
•当cell离开界面就会被放到缓存池中，以供下次复用<br />
如何高性能的给UIImageView加个圆角?<br />
•不好的解决方案<br />
○使用下面的方式会强制Core Animation提前渲染屏幕的离屏绘制,而离屏绘制就会给性能带来负面影响，会有卡顿的现象出现</p>
<p>self.view.layer.cornerRadius = 5;<br />
self.view.layer.masksToBounds = YES;<br />
•正确的解决方案：使用绘图技术</p>
<ul>
<li>(UIImage *)circleImage<br />
{<br />
// NO代表透明<br />
UIGraphicsBeginImageContextWithOptions( self.size, NO, 0.0);<br />
//获得上下文<br />
CGContextRef ctx = UIGraphicsGetCurrentContext();<br />
//添加一个圆<br />
CGRect rect = CGRectMake(0, 0, self.size.width, self.size.height);<br />
CGContextAddEllipseInRect(ctx, rect);<br />
//裁剪<br />
CGContextClip(ctx);<br />
//将图片画上去<br />
[ self drawInRect:rect];<br />
UIImage *image = UIGraphicsGetImageFromCurrentImageContext();<br />
//关闭上下文<br />
UIGraphicsEndImageContext();<br />
return image;<br />
}<br />
•还有一种方案：使用了贝塞尔曲线&quot;切割&quot;个这个图片,给UIImageView添加了的圆角，其实也是通过绘图技术来实现的</li>
</ul>
<p>UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];<br />
imageView.center = CGPointMake(200, 300);<br />
UIImage *anotherImage = [UIImage imageNamed:@&quot;image&quot;];<br />
UIGraphicsBeginImageContextWithOptions(imageView.bounds.size, NO, 1.0);<br />
[[UIBezierPath bezierPathWithRoundedRect:imageView.bounds<br />
cornerRadius:50] addClip];<br />
[anotherImage drawInRect:imageView.bounds];<br />
imageView.image = UIGraphicsGetImageFromCurrentImageContext();<br />
UIGraphicsEndImageContext();<br />
[self.view addSubview:imageView];<br />
#使用drawRect有什么影响？<br />
• drawRect方法依赖Core Graphics框架来进行自定义的绘制<br />
•缺点：它处理touch事件时每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。特别是如果在我们的界面上有多个这样的UIButton实例，那就会很糟糕了<br />
•这个方法的调用机制也是非常特别.当你调用setNeedsDisplay方法时, UIKit将会把当前图层标记为dirty,但还是会显示原来的内容,直到下一次的视图渲染周期,才会将标记为dirty的图层重新建立Core Graphics上下文,然后将内存中的数据恢复出来,再使用CGContextRef进行绘制<br />
#描述下SDWebImage里面给UIImageView加载图片的逻辑<br />
• SDWebImage中为UIImageView提供了一个分类UIImageView+WebCache.h,这个分类中有一个最常用的接口sd_setImageWithURL:placeholderImage:，会在真实图片出现前会先显示占位图片，当真实图片被加载出来后在替换占位图片<br />
•加载图片的过程大致如下：<br />
○首先会在SDWebImageCache中寻找图片是否有对应的缓存,它会以url作为数据的索引先在内存中寻找是否有对应的缓存<br />
○如果缓存未找到就会利用通过MD5处理过的key来继续在磁盘中查询对应的数据,如果找到了,就会把磁盘中的数据加载到内存中，并将图片显示出来<br />
○如果在内存和磁盘缓存中都没有找到，就会向远程服务器发送请求，开始下载图片<br />
○下载后的图片会加入缓存中，并写入磁盘中<br />
○整个获取图片的过程都是在子线程中执行，获取到图片后回到主线程将图片显示出来<br />
#设计个简单的图片内存缓存器<br />
•类似上面SDWebImage实现原理即可<br />
•一定要有移除策略：释放数据模型对象<br />
#控制器的生命周期<br />
•就是问的view的生命周期，下面已经按方法执行顺序进行了排序</p>
<p>//自定义控制器view，这个方法只有实现了才会执行</p>
<ul>
<li>(void)loadView<br />
{<br />
self.view = [[UIView alloc] init];<br />
self.view.backgroundColor = [UIColor orangeColor];<br />
}<br />
// view是懒加载，只要view加载完毕就调用这个方法</li>
<li>(void)viewDidLoad<br />
{<br />
[ super viewDidLoad];<br />
NSLog( @&quot;%s&quot;,<strong>func</strong>);<br />
}<br />
// view即将显示</li>
<li>(void)viewWillAppear:(BOOL)animated<br />
{<br />
[ super viewWillAppear:animated];<br />
NSLog( @&quot;%s&quot;,<strong>func</strong>);<br />
}<br />
// view即将开始布局子控件</li>
<li>(void)viewWillLayoutSubviews<br />
{<br />
[ super viewWillLayoutSubviews];<br />
NSLog( @&quot;%s&quot;,<strong>func</strong>);<br />
}<br />
// view已经完成子控件的布局</li>
<li>(void)viewDidLayoutSubviews<br />
{<br />
[ super viewDidLayoutSubviews];<br />
NSLog( @&quot;%s&quot;,<strong>func</strong>);<br />
}<br />
// view已经出现</li>
<li>(void)viewDidAppear:(BOOL)animated<br />
{<br />
[ super viewDidAppear:animated];<br />
NSLog( @&quot;%s&quot;,<strong>func</strong>);<br />
}<br />
// view即将消失</li>
<li>(void)viewWillDisappear:(BOOL)animated<br />
{<br />
[ super viewWillDisappear:animated];<br />
NSLog( @&quot;%s&quot;,<strong>func</strong>);<br />
}<br />
// view已经消失</li>
<li>(void)viewDidDisappear:(BOOL)animated<br />
{<br />
[ super viewDidDisappear:animated];<br />
NSLog( @&quot;%s&quot;,<strong>func</strong>);<br />
}<br />
//收到内存警告</li>
<li>(void)didReceiveMemoryWarning<br />
{<br />
[ super didReceiveMemoryWarning];<br />
NSLog( @&quot;%s&quot;,<strong>func</strong>);<br />
}<br />
//方法已过期，即将销毁view</li>
<li>(void)viewWillUnload<br />
{<br />
}<br />
//方法已过期，已经销毁view</li>
<li>(void)viewDidUnload<br />
{<br />
}<br />
#你是怎么封装一个view的<br />
•可以通过纯代码或者xib的方式来封装子控件<br />
•建立一个跟view相关的模型，然后将模型数据传给view，通过模型上的数据给view的子控件赋值</li>
</ul>
<p>/**</p>
<ul>
<li>纯代码初始化控件时一定会走这个方法<br />
*/</li>
</ul>
<ul>
<li>(instancetype)initWithFrame:(CGRect)frame<br />
{<br />
if(self = [super initWithFrame:frame])<br />
{<br />
[ self setup];<br />
}<br />
return self;<br />
}<br />
/**</li>
</ul>
<ul>
<li>通过xib初始化控件时一定会走这个方法<br />
*/</li>
</ul>
<ul>
<li>(id)initWithCoder:(NSCoder *)aDecoder<br />
{<br />
if(self = [super initWithCoder:aDecoder])<br />
{<br />
[ self setup];<br />
}<br />
return self;<br />
}</li>
<li>(void)setup<br />
{<br />
//初始化代码<br />
}<br />
#如何进行iOS6、7的适配<br />
•通过判断版本来控制，来执行响应的代码<br />
•功能适配：保证同一个功能在6、7上都能用<br />
• UI适配：保证各自的显示风格</li>
</ul>
<p>// iOS版本为7.0以上（包含7.0）<br />
#define iOS7 ([[UIDevice currentDevice].systemVersion doubleValue]&gt;=7.0)<br />
#如何渲染UILabel的文字？<br />
•通过NSAttributedString/NSMutableAttributedString（富文本）<br />
#UIScrollView的contentSize能否在viewDidLoad中设置？<br />
•能<br />
•因为UIScrollView的内容尺寸是根据其内部的内容来决定的，所以是可以在viewDidLoad中设置的<br />
•补充：（这仅仅是一种特殊情况）<br />
○前提，控制器B是控制器A的一个子控制器，且控制器B的内容只在控制器A的view的部分区域中显示<br />
○假设控制器B的view中有一个UIScrollView这样一个子控件<br />
○如果此时在控制器B的viewDidLoad中设置UIScrollView的contentSize的话会导致不准确的问题<br />
○因为任何控制器的view在viewDidLoad的时候的尺寸都是不准确的，如果有子控件的尺寸依赖父控件的尺寸，在这个方法中设置会导致子控件的frame不准确，所以这时应该在下面的方法中设置子控件的尺寸</p>
<p>-(void)viewDidLayoutSubviews;<br />
#触摸事件的传递<br />
•触摸事件的传递是从父控件传递到子控件<br />
•如果父控件不能接收触摸事件，那么子控件就不可能接收到触摸事件<br />
•不能接受触摸事件的四种情况<br />
○不接收用户交互，即：userInteractionEnabled =NO<br />
○隐藏，即：hidden =YES<br />
○透明，即：alpha &lt;= 0.01<br />
○未启用，即：enabled =NO<br />
•提示：UIImageView的userInteractionEnabled默认就是NO，因此UIImageView以及它的子控件默认是不能接收触摸事件的<br />
•如何找到最合适处理事件的控件：<br />
○首先，判断自己能否接收触摸事件<br />
§可以通过重写hitTest:withEvent:方法验证<br />
○其次，判断触摸点是否在自己身上<br />
§对应方法pointInside:withEvent:<br />
○从后往前(先遍历最后添加的子控件)遍历子控件，重复前面的两个步骤<br />
○如果没有符合条件的子控件，那么就自己处理<br />
#事件响应者链<br />
•如果当前view是控制器的view，那么就传递给控制器<br />
•如果控制器不存在，则将其传递给它的父控件<br />
•在视图层次结构的最顶层视图也不能处理接收到的事件或消息，则将事件或消息传递给UIWindow对象进行处理<br />
•如果UIWindow对象也不处理，则将事件或消息传递给UIApplication对象<br />
•如果UIApplication也不能处理该事件或消息，则将其丢弃<br />
•补充：如何判断上一个响应者<br />
○如果当前这个view是控制器的view，那么控制器就是上一个响应者<br />
如果当前这个view不是控制器的view，那么父控件就是上一个响应者</p>
<p>#如何实现类似QQ的三角形头像<br />
• Quartz2D<br />
•使用coreGraphics裁剪出一个三角形<br />
#核心动画里包含什么？<br />
•基本动画<br />
•回头自己总结吧<br />
#如何使用核心动画？<br />
•创建<br />
•设置相关属性<br />
添加到CALayer上，会自动执行动画</p>
<p>已使用 Microsoft OneNote 2016 创建。</p>

        </article>
        <div class="comments-wrap">
          <div class="share-comments">
            
            <script src="https://utteranc.es/client.js"
                    repo="Apolla/gtalk"
                    issue-term="title"
                    theme="github-dark"
                    crossorigin="anonymous"
                    id="github-comment"
                    async>
            </script>
             
            

            

            
          </div>
        </div><!-- end comments wrap -->
      </div>
      <div class="column">
         <div class="card">
  <header class="card-header">
    <p class="card-header-title">
      <i class="fa fa-commenting" aria-hidden="true"></i>&nbsp;&nbsp;
      <span class="tran-notice">Notice</span> 
    </p>
  </header>
  <div class="card-content site-notice">
    <div class="content"> 
        
    </div>
  </div>                    
</div>
<div class="card">
  <header class="card-header">
    <p class="card-header-title">
      <i class="fa fa-folder-open" aria-hidden="true"></i>&nbsp;&nbsp;
      <span class="tran-site-categories">Categories</span> 
    </p>
  </header>
  <div class="card-content site-categories">
    <div class="content"> 
      <ul>
      
        <li><a href="%E7%BB%84%E4%BB%B6%E5%8C%96.html">组件化</a>
          
          
          
        </li> 
      
        <li><a href="%E7%A2%8E%E7%89%87%E8%8A%9D%E5%A3%AB%E6%94%B6%E8%97%8F.html">碎片芝士收藏</a>
          
          
          
        </li> 
      
        <li><a href="%E7%9B%B4%E6%92%AD.html">直播</a>
          
          
          
        </li> 
      
        <li><a href="coreBluetooth.html">coreBluetooth</a>
          
          
          
        </li> 
      
        <li><a href="%E4%B8%80%E9%98%85%E9%98%85%E8%AF%BB.html">一阅阅读</a>
          
          
          
        </li> 
      
        <li><a href="SwiftUI.html">SwiftUI</a>
          
          
          
        </li> 
      
        <li><a href="%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8.html">葵花宝典</a>
          
          
          
        </li> 
      
      </ul>
    </div>
  </div>                    
</div>
<div class="card">
  <header class="card-header">
    <p class="card-header-title">
      <i class="fa fa-tags" aria-hidden="true"></i>&nbsp;&nbsp;
      <span class="tran-site-tags">Tags</span> 
    </p>
  </header>
  <div class="card-content site-tags">
    <div class="content">
      <div class="tags">
      
      </div>
    </div>
  </div>
</div>

      </div>
    </div><!-- end columns -->
  </div><!-- end container -->
</section>



    <footer class="footer">
    <div id="plt"></div>
    <div class="content has-text-centered">
      <p>
        Copyright &copy; 2019
        <span id="tran-author" class="tran-author">Author: </span><a target="_blank" href="http://apolla.cc">宋明</a>,&nbsp; 
        <span class="tran-theme">Theme: </span><a target="_blank" href="https://github.com/AlanAlbert/atheme">Atheme</a> (Based on BulmaCSS).
      </p>
    </div>
  </footer>



  













<script type="text/javascript">
  var imgApi = "https://source.unsplash.com/random/1024x";
  var imgContainers = document.getElementsByClassName('random-img');
  for (var i = 0; i <= imgContainers.length - 1; i++) {
    // https://picsum.photos/1024/
    var img = document.createElement('img');
    img.src = imgApi + (400 + i);
    imgContainers[i].appendChild(img);
  }
</script>


<script type="text/javascript">
  
    
    var modelJson = 'asset/cat/black/hijiki.model.json';
    var pluginRootPath = 'asset/cat/black';
    var pluginModelPath = 'asset/cat/black';
    
  
  

  var config = {
    pluginRootPath: pluginRootPath,
    pluginJsPath: "lib/",
    pluginModelPath: pluginModelPath,
    tagMode:false,
    debug:false,
    model: {
      jsonPath: modelJson,  // xxx.model.json 的路径
    },
    display: {
      width: 325,           // canvas的宽度
      height: 300,          // canvas的高度
      position: 'right',    // 显示位置：左或右
      hOffset: -75,         // canvas水平偏移
      vOffset: 0,           // canvas垂直偏移
    },
    dialog:{
      enable: true
    },
    mobile: {
      show: false,         // 是否在移动设备上显示
    },
    react: {
      opacity: 1,         // 透明度
    },
    log: false,
  };
  L2Dwidget.init(config);
</script>


  
    




  </body>
</html>
