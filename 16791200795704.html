<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width,initial-scale=0.8,minimum-scale=0.8, maximum-scale=0.8,user-scalable=no,viewport-fit=cover">
    <title>
      
    面试 (一) _ 基础篇 - 宋明的博客
    
    </title>
    

    
    
    <link href="atom.xml" rel="alternate" title="宋明的博客" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/style.min.css">
    <link rel="stylesheet" href="asset/css/doc.css">
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css">
    <!-- Global site tag (gtag.js) - Google Analytics -->
    
    <!-- 百度分析 -->
    
    
      <script src="https://cdn.jsdelivr.net/npm/live2d-widget@3.x/lib/L2Dwidget.min.js"></script>
    
    <script src="asset/app.js"></script>
</head>
  <body style="overflow-x: hidden;">
    <section class="hero">
      <div class="hero-head">
          <nav class="navbar" role="navigation" aria-label="main navigation">
              <div class="container">
              <div class="navbar-brand">
                
                <a target="self" class="navbar-item " href="index.html">Home</a>
                
                <a target="_self" class="navbar-item " href="archives.html">Archives</a>
                

                <a role="button" id="navbarSNSRssSwitchBtn" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarSNSRssButtons">
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                  <span aria-hidden="true"></span>
                </a>
              </div>
            
              <div id="navbarSNSRssButtons" class="navbar-menu">
                <div class="navbar-start">
                  
                </div>
            
                <div class="navbar-end">
                  <div class="navbar-item">
                    <!--buttons start-->
                    <div class="buttons">
                      
                      
                      
                      
                      
                      
                      
                      <a href="mailto: 1317345135@qq.com" target="_blank" title="email">
                        <span class="icon is-large has-text-grey-darker">
                          <svg class="svg-inline--fa fa-email fa-w-14 fa-lg" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1208" width="200" height="200"><path fill="currentColor" d="M935.335233 153.62202h-846.666656a84.666666 84.666666 0 0 0-84.666666 84.666666v550.333327a84.666666 84.666666 0 0 0 84.666666 84.666665h846.666656a84.666666 84.666666 0 0 0 84.666666-84.666665v-550.333327a84.666666 84.666666 0 0 0-84.666666-84.666666z m-27.293711 213.952665L557.558216 549.672927a94.993177 94.993177 0 0 1-87.065555 0.197555l-354.612218-182.202664a42.333333 42.333333 0 0 1 38.698311-75.308177l354.606573 182.202664a10.196689 10.196689 0 0 0 9.341556-0.022577l350.477662-182.089776a42.333333 42.333333 0 1 1 39.034155 75.127555z" fill="#2c2c2c" p-id="1209"></path></svg>
                        </span>
                      </a>
                      
                      
                      <a href="atom.xml" target="_blank" title="RSS">
                        <span class="icon is-large has-text-black-bis">
                          <svg class="svg-inline--fa fa-rss fa-w-14 fa-lg" aria-hidden="true" focusable="false" data-prefix="fas" data-icon="rss" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512" data-fa-i2svg=""><path fill="currentColor" d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328 0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765 0 183.105 0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686 0 38.981 0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"></path></svg><!-- <i class="fas fa-rss fa-lg"></i> -->
                        </span>
                      </a>
                    </div>
                    <!--buttons end-->

                  </div>
                </div>
                </div>
              </div>
            </nav>
      </div>

 <div class="hero-body ct-body"></div>
      
</section>
<section class="ct-body">
  <div class="container">
    <div class="columns is-variable bd-klmn-columns is-4">
      <div class="column is-two-thirds">
        <div class="post-body single-content">      
          <div class="card-image">
            <figure class="random-img">
            </figure>
          </div>
          <h1 class="title">
            面试 (一) _ 基础篇   
          </h1>
           
          <div class="media">
            
            <figure class="media-left">
              <p class="image is-48x48">
                
                  <img class="is-rounded" src="">
              </p>
            </figure>
            
            <div class="media-content">
              <div class="content">
                <p style="line-height: 30px; font-size: 12px;">
                  
                  <a href="http://apolla.cc">宋明</a>
                  &nbsp;&nbsp;&nbsp;<span style="color: #ccc;">|</span>&nbsp;&nbsp;&nbsp;
                  
                  <span class="date"><i class="fa fa-calendar-check-o" aria-hidden="true"></i>&nbsp;2023/03/18</span>
                  
                  <span class="tran-posted-in">posted in</span>&nbsp; 
                  
                  
                    <span class="posted-in"><a href='%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8.html'><i class="fa fa-folder" aria-hidden="true"></i>&nbsp;&nbsp;葵花宝典</a></span>
                       
                  

                  

                  
                  
                </p>
              </div>
            </div>
          </div>
        </div>
        <article class="markdown-body single-content">
          <h2><a id="%E7%88%B6%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%97%B6%EF%BC%8C%E5%AD%90%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D%E3%80%82%E7%88%B6%E7%B1%BB%E6%B2%A1%E6%9C%89%E5%AE%9E%E7%8E%B0%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%97%B6%EF%BC%8C%E5%AD%90%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>父类实现深拷贝时，子类如何实现深度拷贝。父类没有实现深拷贝时，子类如何实现深度拷贝。</h2>
<ul>
<li>
<p>深拷贝同浅拷贝的区别：浅拷贝是指针拷贝，对一个对象进行浅拷贝，相当于对指向对象的指针进行复制，产生一个新的指向这个对象的指针，那么就是有两个指针指向同一个对象，这个对象销毁后两个指针都应该置空。深拷贝是对一个对象进行拷贝，相当于对对象进行复制，产生一个新的对象，那么就有两个指针分别 指向两个对象。当一个对象改变或者被销毁后拷贝出来的新的对象不受影响。</p>
</li>
<li>
<p>实现深拷贝需要实现NSCoying协议，实现- (id)copyWithZone:(NSZone *)zone方法。当对一个property属性含有copy修饰符的时候，在进行赋值操作的时候实际上就是调用这个方法。</p>
</li>
<li>
<p>父类实现深拷贝之后，子类只要重写copyWithZone方法，在方法内部调用父类的copyWithZone方法，之后实现自己的属性的处理</p>
</li>
<li>
<p>父类没有实现深拷贝，子类除了需要对自己的属性进行处理，还要对父类的属性进行处理。</p>
</li>
</ul>
<h2><a id="kvo%EF%BC%8Cnsnotification%EF%BC%8Cdelegate%E5%8F%8Ablock%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>KVO，NSNotification，delegate及block区别</h2>
<ul>
<li>
<p>KVO就是cocoa框架实现的观察者模式，一般同KVC搭配使用，通过KVO可以监测一个值的变化，比如View的高度变化。是一对多的关系，一个值的变化会通知所有的观察者。</p>
</li>
<li>
<p>NSNotification是通知，也是一对多的使用场景。在某些情况下，KVO和NSNotification是一样的，都是状态变化之后告知对方。NSNotification的特点，就是需要被观察者先主动发出通知，然后观察者注册监听后再来进行响应，比KVO多了发送通知的一步，但是其优 点是监听不局限于属性的变化，还可以对多种多样的状态变化进行监听，监听范围广，使用也更灵活。</p>
</li>
<li>
<p>delegate是代理，就是我不想做的事情交给别人做。比如狗需要吃饭，就通过delegate通知主人，主人就会给他做饭、盛饭、倒水，这些操作，这些狗都不需要关 心，只需要调用delegate（代理人）就可以了，由其他类完成所需要的操作。所以delegate是一对一关系。</p>
</li>
<li>
<p>block是delegate的另一种形式，是函数式编程的一种形式。使用场景跟delegate一样，相比delegate更灵活，而且代理的实现更直观。</p>
</li>
<li>
<p>KVO一般的使用场景是数据，需求是数据变化，比如股票价格变化，我们一般使用KVO（观察者模式）。delegate一般的使用场景是行为，需求是需要别人帮我做一件事情，比如买卖股票，我们一般使用delegate。</p>
</li>
</ul>
<p>Notification一般是进行全局通知，比如利好消息一出，通知大家去买入。delegate是强关联，就是委托和代理双方互相知道，你委托别人买股票你就需要知道经纪人， 经纪人也不要知道自己的顾客。Notification是弱关联，利好消息发出，你不需要知道是谁发的也可以做出相应的反应，同理发消息的人也不需要知道 接收的人也可以正常发出消息。</p>
<h2><a id="%E5%B0%86%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%9C%A8%E4%B8%BB%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E7%9A%844%E7%A7%8D%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将一个函数在主线程执行的4种方法</h2>
<p>• GCD方法，通过向主线程队列发送一个block块，使block里的方法可以在主线程中执行。</p>
<pre class="line-numbers"><code class="language-objectivec">dispatch_async(dispatch_get_main_queue(), ^{
   //需要执行的方法
});
</code></pre>
<p>• NSOperation方法</p>
<pre class="line-numbers"><code class="language-objectivec">NSOperationQueue *mainQueue = [NSOperationQueue mainQueue]; 主队列
NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^{
  // 需要执行的方法
}];
[mainQueue addOperation:operation];
</code></pre>
<p>• NSThread方法</p>
<pre class="line-numbers"><code class="language-objectivec">[self performSelector:@selector(method) onThread:[NSThread mainThread] withObject:nil waitUntilDone:YES modes:nil];
[self performSelectorOnMainThread:@selector(method) withObject:nil waitUntilDone:YES];
[[NSThread mainThread] performSelector:@selector(method) withObject:nil];
</code></pre>
<p>• RunLoop方法</p>
<pre class="line-numbers"><code class="language-objectivec">[[NSRunLoop mainRunLoop] performSelector:@selector(method) withObject:nil];
</code></pre>
<h2><a id="%E5%A6%82%E4%BD%95%E8%AE%A9%E8%AE%A1%E6%97%B6%E5%99%A8%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何让计时器调用一个类方法</h2>
<p>•计时器只能调用实例方法，但是可以在这个实例方法里面调用静态方法。<br />
•使用计时器需要注意，计时器一定要加入RunLoop中，并且选好model才能运行。scheduledTimerWithTimeInterval方法创建一个计时器并加入到RunLoop中所以可以直接使用。<br />
•如果计时器的repeats选择YES说明这个计时器会重复执行，一定要在合适的时机调用计时器的invalid。不能在dealloc中调用， 因为一旦设置为repeats为yes，计时器会强持有self，导致dealloc永远不会被调用，这个类就永远无法被释放。比如可以在viewDidDisappear中调用，这 样当类需要被回收的时候就可以正常进入dealloc中了。</p>
<pre class="line-numbers"><code class="language-objectivec">[NSTimer scheduledTimerWithTimeInterval:1 target:self selector:@selector(timerMethod) userInfo:nil repeats:YES];
-(void)timerMethod
{
   //调用类方法
    [[self class] staticMethod];
}
-(void)invalid
{
    [timer invalid];
    timer = nil;
}
</code></pre>
<h2><a id="%E5%A6%82%E4%BD%95%E9%87%8D%E5%86%99%E7%B1%BB%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何重写类方法</h2>
<p>• 1、在子类中实现一个同基类名字一样的静态方法<br />
• 2、在调用的时候不要使用类名调用，而是使用[self class]的方式调用。原理，用类名调用是早绑定，在编译期绑定，用[self class]是晚绑定，在运行时决定调用哪个方法。</p>
<h2><a id="nstimer%E5%88%9B%E5%BB%BA%E5%90%8E%EF%BC%8C%E4%BC%9A%E5%9C%A8%E5%93%AA%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NSTimer创建后，会在哪个线程运行。</h2>
<p>•用scheduledTimerWithTimeInterval创建的，在哪个线程创建就会被加入哪个线程的RunLoop中就运行在哪个线程<br />
•自己创建的Timer，加入到哪个线程的RunLoop中就运行在哪个线程。</p>
<h2><a id="id%E5%92%8Cnsobject%EF%BC%8A%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>id和NSObject＊的区别</h2>
<p>•id是一个objc_object结构体指针，定义是typedef structobjc_object *id<br />
•id可以理解为指向对象的指针。所有oc的对象id都可以指向，编译器不会做类型检查，id调用任何存在的方法都不会在编译阶段报错，当然如果这个id指向的对象没有这个方法，该崩溃还是会崩溃的。<br />
• NSObject *指向的必须是NSObject的子类，调用的也只能是NSObjec里面的方法否则就要做强制类型转换。<br />
•不是所有的OC对象都是NSObject的子类，还有一些继承自NSProxy。NSObject *可指向的类型是id的子集。<br />
以下内容后续补充</p>
<h2><a id="ios%E6%A0%B8%E5%BF%83%E6%A1%86%E6%9E%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>iOS核心框架</h2>
<p>• CoreAnimation<br />
• CoreGraphics<br />
• CoreLocation<br />
• AVFoundation<br />
• Foundation</p>
<h2><a id="ios%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>iOS核心机制</h2>
<p>• UITableView重用<br />
• ObjC内存管理；自动释放池，ARC如何实现<br />
• runloop<br />
• runtime<br />
• Block的定义、特性、内存区域、如何实现<br />
• Responder Chain<br />
• NSOperation</p>
<h2><a id="gcd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>GCD</h2>
<p>数据结构<br />
• 8大排序算法<br />
•二叉树实现<br />
•二分查找实现</p>
<h2><a id="%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>面向对象编程</h2>
<p>•封装、继承、多态<br />
•设计模式6个原则<br />
•设计一个类的功能，如何划分粒度（单一职责）<br />
•接口隔离。<br />
•如果有一个鸟类，有飞的动作，一个鸵鸟继承它是合适的吗（里氏替换）<br />
•类之间的依赖如何依赖偶合度最小（依赖倒转）<br />
高层依赖低层，低层不能依赖高层。依赖接口，不能依赖具体的类。<br />
•如果A要调用C函数，但C是B的成员类，应该如何设计？（迪米特法则）<br />
•如何设计类，能做到只增加代码，而不修改代码，有哪些经验（开放封闭）<br />
通过设计模式解决。</p>
<h2><a id="%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8A%80%E6%9C%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>计算机技术</h2>
<p>•计算机网络：TCP/IP、HTTPCDN、SPDY<br />
•计算机安全：RSA、AES、DES<br />
•操作系统：线程、进程、堆栈、死锁、调度算法</p>
<h2><a id="ios%E6%96%B0%E7%89%B9%E6%80%A7%E3%80%81%E6%96%B0%E6%8A%80%E6%9C%AF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>iOS新特性、新技术</h2>
<p>• iOS7 UIDynamic、SpritKit、新布局、扁平化<br />
• iOS8应用程序扩展、HealthKit、SceneKit、CoreLocation、TouchID、PhotoKit<br />
• iOS9<br />
• Apple Watch</p>
<h2><a id="%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%EF%BC%9Asdwebimage%E3%80%81afnetwork%E3%80%81jsonkit%E3%80%81wax" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>第三方库：SDWebImage、AFNetwork、JSONKit、wax</h2>
<h2><a id="%E7%AC%94%E8%AE%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>笔记</h2>
<h3><a id="%E7%AE%80%E8%BF%B0oc%E4%B8%AD%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>简述OC中内存管理机制.</h3>
<p>答:内存管理机制:使用引用计数管理,分为ARC和MRC,MRC需要程序员自己管理内存,ARC则不需要.但是并不是所有对象在ARC环境下均不需要管理内存,子线程和循环引用并不是这样.与retain配对使用的是release,retain代表引用计数+1,release代表引用计数-1,当引用计数减为0时,对象则被系统自动销毁.与alloc配对使用的是dealloc,alloc代表为对象开辟内存空间,dealloc则代表销毁对象的内存空间.</p>
<h3><a id="readwrite-readonly-assign-retain-copy-nonatomic-atomic-strong-weak%E7%9A%84%E4%BD%9C%E7%94%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>readwrite,readonly,assign,retain,copy,nonatomic,atomic,strong,weak的作用?</h3>
<p>答:读写属性:readonly和readwrite; 语义属性:assign/retain/copy;  原子性:nonatomic.</p>
<p>①.readwrite代表可读,可写,即有setter和getter方法,是默认属性.readonly代表只可读,即只有get方法,因为不会生成setter方法,所以它不可以和copy/retain/assign组合使用.</p>
<p>②.weak和assign均是弱引用,assign修饰基本数据类型,weak修饰对象类型.strong和weak用于ARC下(ARC下的代理使用weak,block块使用copy).strong相当于retain.weak相当于assign;assign/retain/copy这些属性用于指定set访问器的语义,也就是说,这些属性决定了以何种方式对数据成员赋值.</p>
<p>assign,直接赋值,引用计数不改变,适用于基本数据类型.</p>
<p>retain,浅拷贝,使用的是原来的内存空间,只能适用于Objective-C对象类型,而不能适用于Core Foundation对象(retain会增加对象的引用计数,而基本数据和Core Foundation对象都没有引用计数).</p>
<p>copy:对象的拷贝,新申请一块内存空间,并把原始内容复制到那片空间.新对象的引用计数为1,此属性只对那些遵循了NSCopy协议的对象类型有效.</p>
<p>③.nonatomic,非原子性访问,不加同步,是异步操作.默认为atomic,原子操作,atomic是Objc使用的一种线程保护技术,基本上来讲,是防止在写未完成的时候被另外一个线程读取,造成数据错误,而这种机制是消耗系统内存资源的,所以在移动端,都选择nonatomic.</p>
<h3><a id="%E5%86%85%E5%AD%98%E5%88%86%E4%B8%BA5%E4%B8%AA%E5%8C%BA%E5%88%86%E5%88%AB%E6%98%AF%E6%A0%88%E5%8C%BA%E5%A0%86%E5%8C%BA%E5%85%A8%E5%B1%80%E5%8C%BA%E6%96%87%E5%AD%97%E5%B8%B8%E9%87%8F%E5%8C%BA%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81%E5%8C%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>内存分为5个区,分别是栈区,堆区,全局区,文字常量区,程序代码区.</h3>
<p>栈区:由编译器自动分配释放,不需要管理内存.<br />
堆区:一般有程序员分配释放.<br />
全局区:存放全局变量和静态变量.<br />
常量区:存放常量字符串.<br />
代码区:存放二进制代码.</p>
<h3><a id="%E7%B1%BB%E5%8F%98%E9%87%8F%E7%9A%84protected-private-public-package%E5%A3%B0%E6%98%8E%E5%90%84%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>类变量的@protected,@private,@public,@package,声明各有什么含义?</h3>
<p>@protected受保护的.本类,子类可见.<br />
@private私有的,类内可用<br />
@public公有的,类内,子类,外部均可用<br />
@package可见度在@protected和@public之间,这个类型最常用于框架类的实例变量.</p>
<h3><a id="%E7%BA%BF%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E8%BF%9B%E7%A8%8B%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线程是什么?进程又是什么?区别和联系.</h3>
<ul>
<li>进程:正在运行的程序,负责程序的内存分配.</li>
<li>线程:线程是进程中一个独立执行的控制单元(路径),一个进程至少包含一条线程,即主线程.</li>
<li>创建线程的目的:开辟一条新的执行路径,运行指定的代码,与主线程的代码实现同时执行.</li>
</ul>
<h3><a id="%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3ios%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>对多线程开发的理解,iOS中有几种实现多线程的方式.</h3>
<p>多线程的使用场景:防止卡顿,可以同时完成多个任务,且不影响主线程,把耗时操作放在子线程中执行,但是会消耗内存.<br />
实现多线程的方式:<br />
①.NSThread(内存需要自己管理.触发),<br />
②.NSOperationQueue(不再关注线程,当前可执行任务个数queue.maxConcurrentOperationCount)<br />
③.GCD</p>
<h3><a id="%E8%AF%A6%E8%A7%A3%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>详解三种实现多线程的方式：</h3>
<h4><a id="gcd" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>GCD:</h4>
<blockquote>
<p>GCD里面包含了串行队列、并行队列、主队列、全局队列。</p>
</blockquote>
<pre class="line-numbers"><code class="language-objectivec">Dispatch_queue_t q = dispatch_queue_create(“qqq”,DISPATCH_QUEUE_SERIAL);创建一个串行队列
 
Dispatch_sync(q,^{
    
});//开启同步任务
 
Dispatch_async(q,^{
    
});//开启异步任务
// 并行队列：
DISPATCH_QUEUE_CONCURRENT
 
//主队列：
dispatch_queue_t q = dispatch_get_main_queue();
 
// 全局队列：
dispatch_queue_t q = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,0);

</code></pre>
<h4><a id="nsthread" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NSThread</h4>
<p>获取当前线程：NSThread * current = [NSThread currentThread];<br />
获取主线程：NSThread * main = [NSThread mainThread];<br />
创建线程的两种方式：</p>
<pre class="line-numbers"><code class="language-objectivec">- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument;
 
+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument;
//暂停当前线程：
[NSThread sleepForTimeInterval:2];
</code></pre>
<h4><a id="nsoperationqueue" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NSOperationQueue</h4>
<pre class="line-numbers"><code class="language-objectivec">

 
//创建一个操作队列：
NSOperationQueue * queue = [[NSOperationQueue alloc]init];
 
//添加NSOperation到NSOperationQueue中：
[queue addOperation:operation];
 
//添加一组operation：
[queue addOperations:operations waitUntilFinished:NO];
 
//添加一个block形式的operation：
[queue addOperationWithBlock:^(){
    
}];
 
//添加NSOperation的依赖对象：
[operation2 addDependency:operation1];
 
//设置队列的最大操作数：
[queue setMaxConcurrentOperationCount:1];
 
//等待options完成：
[operation waitUntilFinished];
 
//暂停、继续queue:
[queue setSuspended:YES] [queue setSuspend:NO]
</code></pre>
<h3><a id="6%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB-ios%E4%B8%AD%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>6.线程同步和异步的区别?ios中如何实现线程的同步?</h3>
<p>同步:任务顺序执行,下一个任务依赖于上一任务的完成.</p>
<p>异步:任务执行顺序不定,一起执行.</p>
<p>实现:设置依赖:NSOpreationQueue  GCD中的串行队列.</p>
<h3><a id="7-ios%E7%B1%BB%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%A4%9A%E7%BB%A7%E6%89%BF%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>7.iOS类是否可以多继承,如果没有,怎么实现?</h3>
<p>不可以多继承.可以通过类目,延展,协议实现多继承.</p>
<p>类目:类目也叫分类,英文category,在没有原类.m文件的基础上,给该类添加方法.类目里不能添加实例变量,不能添加和原始类方法名相同的方法,否则会发生覆盖.一个类可以添加多个类目,类目中的方法可以成为原始类的一部分,和原始类方法级别相同,可以被子类继承.</p>
<p>延展:Extension,是一种特殊形式的类目,主要是在一个类的.m里面声明与实现.作用:就是给某类添加私有方法或者私有变量.</p>
<p>虽然延展是给一个类定义私有方法,但是OC没有绝对的私有方法,其实还是可以调用的,延展里面声明的变量只能在该类内部使用,外界访问不了.如果是新建文件建的的某类延展.h文件,则不能添加实例变量,如果括号里没有类目名,则认为延展里面的方法为全都必须实现,如果有,则可选实现.</p>
<p>类目写的方法必须实现,延展写的方法非必须.</p>
<h3><a id="8%E6%A0%88%E5%92%8C%E5%A0%86%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>8.栈和堆的区别?</h3>
<p>栈:内存系统管理(系统开辟,系统释放),先进后出.<br />
堆:内存自己管理(自己开辟,自己释放).先进先出.</p>
<p>9.iOS本地数据存储都有几种方式?<br />
①.NSkeyedArchiver:采用归档的形式来保存数据,该数据对象需要遵守NSCoding协议,并且该对象对应的类必须提供encodeWithCoder:和initWithCoder:方法.前一个方法告诉系统怎么对对象进行编码,而后一个方法则是告诉系统怎么对对象进行解码.</p>
<p>②.NSUserDefaults:用来保存应用程序设置和属性,用户保存的数据.用户再次打开程序或者开机后这些数据仍然存在.NSUserDefaults可以存储的数据类型包括:NSData,NSString,NSNumber,NSDate,NSArray.NSDictionary,其他类型的数据需要先行转换.</p>
<p>③.Write写入方式:永久保存在磁盘中.具体:a.获得文件保存的路径.b.生成该路径下的文件,c,往文件中写入数据.d.从文件中读出数据.</p>
<p>④.SQLite:采用SQLite数据库来存储数据,SQLite作为一种轻量级数据库.具体:a.添加SQLite相关的库以及头文件,b.使用数据库存数数据:打开数据库,编写数据库语句,执行,关闭数据库.另:写入数据库,字符串可以采用char方式,而从数据库中取出char类型,当char类型有表示中文字符时,会出现乱码,这是因为数据库默认使用ascII编码方式,所以想要正确从数据库中取出中文,需要使用NSString来接受从数据库取出的字符串.</p>
<p>⑤.CoreData:原理是对SQLite的封装,开发者不需要接触sql语句,就可以对数据库进行操作.</p>
<h3><a id="10-ios%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>10.ios动态类型和动态绑定</h3>
<p>多态:父类指针指向子类对象.<br />
动态类型:只有在运行期,才能确定其真正类型.<br />
动态加载:根据不同的条件,加载不同的资源.32和64位.</p>
<h3><a id="11%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E7%90%86%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>11.深拷贝和浅拷贝的理解.</h3>
<p>深拷贝;拷贝的内容.<br />
浅拷贝:拷贝的指针.</p>
<p>深拷贝如:<br />
NSMutableDictionary  * dic = [@{} mutableCopy];<br />
NSMutableArray  * ary = [@[] mutableCopy];</p>
<h3><a id="12%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8D%95%E4%BE%8B%E7%9A%84%E7%B1%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>12.怎么实现一个单例的类.</h3>
<p>单例是一种设计模式,对象只有一个.缺点:对象不会被释放,如果创建很多的话会占用很多内存,优点:可以当做工具类使用.</p>
<pre class="line-numbers"><code class="language-objectivec">static SortDetailsModelDown * single = nil;
 
+(SortDetailsModelDown *)shareSortDetailsModelDown{
    
   @synchronized(self){
        
        if (!single) {
            
            single = [[SortDetailsModelDown alloc]init];
            
        }
        
    }
    
    return single;
    
}
</code></pre>
<h3><a id="13%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%89%E5%85%A8%E9%87%8A%E6%94%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>13.什么是安全释放?</h3>
<p>先释放再置空.</p>
<h3><a id="14-runloop%E6%98%AF%E4%BB%80%E4%B9%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>14.RunLoop是什么?</h3>
<p>事件循环,是线程里面的一个组件.主线程的RunLoop是自动开启的.分为:计时源(timer source),事件源(输入源):input source.防止CPU中断(保证程序执行的线程不会被系统终止).</p>
<p>Runloop提供了一种异步执行代码的机制,并不能并行执行任务,是事件接收和分发机制的一个实现.每一个线程都有其对应的RunLoop,但是默认非主线程的RunLoop是没有运行的,需要为RunLoop添加至少一个事件源,然后run它.</p>
<p>一般情况下我们是没有必要去启动线程的RunLoop的,除非你在一个单独的线程中需要长时间的检测某个事件.</p>
<p>RunLoop,正如其名所示,是线程进入和被线程用来响应事件以及调用事件处理函数的地方.</p>
<p>input source传递异步事件,通常是来自其他线程和不同程序的消息.</p>
<p>timer source传递同步事件.</p>
<p>当有事件发生时,RunLoop会根据具体的事件类型通知应用程序作出响应.</p>
<p>当没有事件发生时,RunLoop会进入休眠状态,从而到达省电的目的.</p>
<p>当事件再次发生时,RunLoop会被重新唤醒,处理事件.</p>
<p>一般在开发中很少会主动创建RunLoop,而通常会把事件添加到RunLoop中.</p>
<h3><a id="15%E4%BB%80%E4%B9%88%E6%98%AF%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%AF%E4%BB%A5%E7%94%A8%E6%9D%A5%E5%81%9A%E4%BB%80%E4%B9%88%E5%A6%82%E4%BD%95%E5%9C%A8-oc%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%A4%8D%E6%9D%82%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%98%E5%82%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>15.什么是序列化和反序列化,可以用来做什么?如何在OC中实现复杂对象的存储.</h3>
<p>序列化和反序列化:归档和反归档,进行本地化,进行数据存储.<br />
CoreData:数据托管.有四种存储方式:xml,sqlite,二进制,内存.<br />
遵循NSCoding协议之后,进行归档即可实现复杂对象的存储.</p>
<h3><a id="16%E5%86%99%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E5%AE%8F-min%E8%BF%99%E4%B8%AA%E5%AE%8F%E8%BE%93%E5%85%A5%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E5%B9%B6%E8%BF%94%E5%9B%9E%E8%BE%83%E5%B0%8F%E7%9A%84%E4%B8%80%E4%B8%AA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>16.写一个标准宏MIN,这个宏输入两个参数并返回较小的一个.</h3>
<p>#define MIN(A,B) (A)&gt;(B)?(B):(A)</p>
<h3><a id="17-iphone-os%E6%9C%89%E6%B2%A1%E6%9C%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E7%AE%80%E6%98%93%E9%98%90%E8%BF%B0%E4%B8%80%E4%B8%8B-oc%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>17.iPhone OS有没有垃圾回收机制,简易阐述一下OC内存管理.</h3>
<p>木有.引用计数,ARC和MRC,swift(自动引用计数).</p>
<h3><a id="18%E7%AE%80%E8%BF%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%8C%89-home%E9%94%AE%E8%BF%9B%E5%85%A5%E5%90%8E%E5%8F%B0%E6%97%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%BB%A5%E5%8F%8A%E4%BB%8E%E5%90%8E%E5%8F%B0%E8%BF%9B%E5%85%A5%E5%89%8D%E5%8F%B0%E6%97%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>18.简述应用程序按HOME键进入后台时的生命周期,以及从后台进入前台时的生命周期.</h3>
<p>前者:- (void)applicationWillResignActive:(UIApplication *)application</p>
<ul>
<li>(void)applicationDidEnterBackground:(UIApplication *)application</li>
</ul>
<p>后者:- (void)applicationWillEnterForeground:(UIApplication *)application</p>
<ul>
<li>(void)applicationDidBecomeActive:(UIApplication *)application</li>
</ul>
<p>另:<br />
各个程序运行状态时代理的回调：</p>
<ul>
<li>(BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions</li>
</ul>
<p>告诉代理进程启动但还没进入状态保存</p>
<ul>
<li>(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</li>
</ul>
<p>告诉代理启动基本完成程序准备开始运行</p>
<ul>
<li>(void)applicationWillResignActive:(UIApplication *)application</li>
</ul>
<p>当应用程序将要入非活动状态执行，在此期间，应用程序不接收消息或事件，比如来电话了</p>
<ul>
<li>(void)applicationDidBecomeActive:(UIApplication *)application</li>
</ul>
<p>当应用程序入活动状态执行，这个刚好跟上面那个方法相反</p>
<ul>
<li>(void)applicationDidEnterBackground:(UIApplication *)application</li>
</ul>
<p>当程序被推送到后台的时候调用。所以要设置后台继续运行，则在这个函数里面设置即可</p>
<ul>
<li>(void)applicationWillEnterForeground:(UIApplication *)application</li>
</ul>
<p>当程序从后台将要重新回到前台时候调用，这个刚好跟上面的那个方法相反。</p>
<ul>
<li>(void)applicationWillTerminate:(UIApplication *)application</li>
</ul>
<p>当程序将要退出是被调用，通常是用来保存数据和一些退出前的清理工作。这个需要要设置UIApplicationExitsOnSuspend的键值。</p>
<ul>
<li>(void)applicationDidFinishLaunching:(UIApplication*)application</li>
</ul>
<p>当程序载入后执行</p>
<p>在上面8个方法对应的方法中键入NSLog打印。</p>
<p>现在启动程序看看执行的顺序：</p>
<p>启动程序</p>
<p>lifeCycle[40428:11303] willFinishLaunchingWithOptions</p>
<p>lifeCycle[40428:11303] didFinishLaunchingWithOptions</p>
<p>lifeCycle[40428:11303] applicationDidBecomeActive</p>
<p>按下home键</p>
<p>lifeCycle[40428:11303] applicationWillResignActive</p>
<p>lifeCycle[40428:11303] applicationDidEnterBackground</p>
<p>双击home键，再打开程序</p>
<p>lifeCycle[40428:11303] applicationWillEnterForeground</p>
<p>lifeCycle[40428:11303] applicationDidBecomeActive</p>
<h3><a id="19-viewcontroller" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>19.ViewController</h3>
<p>alloc,loadView,viewDidLoad,viewWillAppear,viewDidUnload,dealloc,init分别是在什么时候调用?在自定义ViewController的时候这几个函数里面应该做什么工作?</p>
<p>alloc:申请内存时调用.</p>
<p>loadView:加载视图时调用.</p>
<p>viewDidLoad;视图已经加载后调用.</p>
<p>viewWillAppear:视图将要出现时调用.</p>
<p>viewDidUnload:视图已经加载但是没有加载出来时调用.</p>
<p>dealloc:销毁该视图时调用.</p>
<p>init;初始化该视图时调用.</p>
<h3><a id="20%E6%8F%8F%E8%BF%B0%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>20.描述应用程序的启动顺序.</h3>
<p>a.程序入口main函数创建UIApplication实例和UIApplication代理实例.</p>
<p>b.在UIApplication代理实例中重写启动方法,设置根ViewController</p>
<p>c.在第一ViewController中添加控件,实现应用程序界面.</p>
<h3><a id="21%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BE%88%E5%A4%9A%E5%86%85%E7%BD%AE%E7%B1%BB%E5%A6%82-uitableviewcontrol%E7%9A%84delegate%E5%B1%9E%E6%80%A7%E9%83%BD%E6%98%AFassign%E8%80%8C%E4%B8%8D%E6%98%AFretain" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>21.为什么很多内置类如UITableViewControl的delegate属性都是assign而不是retain?</h3>
<p>防止循环引用.</p>
<p>如:对象A引用了对象B,对象B引用了对象C,对象C引用了对象B,这个时候B的引用计数是2,而C的引用计数是1,当A不再使用B的时候,就释放了B的所有权,这个时候C还引用对象B,所以B不会释放,引用计数为1,因为B也引用着对象C,B不释放,那么C也就不会被释放,所以他们的引用计数都为1,并且永远不会被释放,形成了循环引用.</p>
<h3><a id="22%E4%BD%BF%E7%94%A8-uitableview%E7%9A%84%E6%97%B6%E5%80%99%E5%BF%85%E9%A1%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>22.使用UITableView的时候必须要实现的几种方法?</h3>
<p>2个数据源方法.分别是:</p>
<ul>
<li>
<p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section;</p>
</li>
<li>
<p>(UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;</p>
</li>
</ul>
<h3><a id="23%E5%86%99%E4%B8%80%E4%B8%AA%E9%81%8D%E5%8E%86%E6%9E%84%E9%80%A0%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>23.写一个遍历构造器.</h3>
<p>+(id)leftModelWith{</p>
<pre class="line-numbers"><code class="language-plain_text">leftModel * model = [self alloc]init];

return model;
</code></pre>
<p>}</p>
<h3><a id="24-uiimage%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%89%87%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%E7%AE%80%E8%BF%B0%E5%85%B6%E7%89%B9%E7%82%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>24.UIImage初始化一张图片有几种方法?简述其特点?</h3>
<p>3种,<br />
imageNamed:系统会先检查系统缓存中是否有该名字的image,如果有的话,则直接返回,如果没有,则先加载图像到缓存,然后再返回.</p>
<p>initWithContentsOfFile:系统不会检查缓存,而直接从文件系统中记载并返回.</p>
<p>imageWithCGImage:scale:orientation当scale= 1的时候图像为原始大小,orientation指定绘制图像的方向.</p>
<h3><a id="25-person%E7%9A%84retaincount%E5%80%BC%E5%B9%B6%E8%A7%A3%E9%87%8A%E4%B8%BA%E4%BB%80%E4%B9%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>25.person的retainCount值,并解释为什么?</h3>
<p>Person * per = [Person alloc]init];</p>
<p>self.person = per;</p>
<p>1或者2.看person是什么类型修饰的.</p>
<p>alloc+1,assign+0,retain+1.</p>
<h3><a id="26%E4%B8%8B%E9%9D%A2%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%9C%89%E4%BD%95%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>26.下面这段代码有何问题?</h3>
<p>@implementationPerson</p>
<ul>
<li>
<p>(void)setAge:(int)newAge {</p>
<p>self.age = newAge;</p>
</li>
</ul>
<p>}</p>
<p>@end</p>
<p>死循环</p>
<h3><a id="27%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>27.   这段代码有什么问题,如何修改</h3>
<p>for (int i = 0; i &lt; someLargeNumber; i++) {</p>
<pre class="line-numbers"><code class="language-plain_text">NSString *string = @”Abc”;

string = [string lowercaseString];

string = [string stringByAppendingString:@&quot;xyz&quot;];

NSLog(@“%@”, string);
</code></pre>
<p>}</p>
<p>加入自动释放池@autoreleasepool{};</p>
<p>for (int i = 0; i &lt; someLargeNumber; i++) {</p>
<pre class="line-numbers"><code class="language-plain_text">@antoreleasepool {
    
    NSString *string = @”Abc”;
    
    string = [string lowercaseString];
    
    string = [string stringByAppendingString:@&quot;xyz&quot;];
    
    NSLog(@“%@”, string);
    
}
</code></pre>
<p>}</p>
<h3><a id="28%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2-20-http-www-baidu-com-http-www-baidu-com-22%E4%B8%AD%EF%BC%8C-22-7c-22%E5%AD%97%E7%AC%A6%E5%89%8D%E9%9D%A2%E5%92%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E5%AE%83%E4%BB%AC%E4%B8%AD%EF%BC%8C-http-www-baidu-com-22%E4%B8%AD%EF%BC%8C-22-7c-22%E5%AD%97%E7%AC%A6%E5%89%8D%E9%9D%A2%E5%92%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E5%AE%83%E4%BB%AC-http-www-baidu-com-22%E4%B8%AD%EF%BC%8C-22-7c-22%E5%AD%97%E7%AC%A6%E5%89%8D%E9%9D%A2%E5%92%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E5%AE%83%E4%BB%AC%E5%AD%97%E7%AC%A6%E5%89%8D%E9%9D%A2%E5%92%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E5%AE%83%E4%BB%AC-http-www-baidu-com-22%E4%B8%AD%EF%BC%8C-22-7c-22%E5%AD%97%E7%AC%A6%E5%89%8D%E9%9D%A2%E5%92%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E5%AE%83%E4%BB%AC%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>28.截取字符串&quot;20 |<a href="http://www.baidu.com%22%E4%B8%AD%EF%BC%8C%22%7C%22%E5%AD%97%E7%AC%A6%E5%89%8D%E9%9D%A2%E5%92%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E5%AE%83%E4%BB%AC/">http://www.baidu.com&quot;</a><a href="http://www.baidu.com%22%E4%B8%AD%EF%BC%8C%22%7C%22%E5%AD%97%E7%AC%A6%E5%89%8D%E9%9D%A2%E5%92%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E5%AE%83%E4%BB%AC/">中，</a><a href="http://www.baidu.com%22%E4%B8%AD%EF%BC%8C%22%7C%22%E5%AD%97%E7%AC%A6%E5%89%8D%E9%9D%A2%E5%92%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E5%AE%83%E4%BB%AC/">&quot;|&quot;</a><a href="http://www.baidu.com%22%E4%B8%AD%EF%BC%8C%22%7C%22%E5%AD%97%E7%AC%A6%E5%89%8D%E9%9D%A2%E5%92%8C%E5%90%8E%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%8C%E5%88%86%E5%88%AB%E8%BE%93%E5%87%BA%E5%AE%83%E4%BB%AC/">字符前面和后面的数据，分别输出它们</a>。</h3>
<p>[&quot;20 |<a href="http://www.baidu.com/">http://www.baidu.com</a>&quot; componentSeparatedByString:@&quot;|&quot;];</p>
<h3><a id="29%E7%94%A8-obj-c%E5%86%99%E4%B8%80%E4%B8%AA%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>29.用obj-c写一个冒泡排序.</h3>
<pre class="line-numbers"><code class="language-objectivec">NSMutableArray *ary = [@[@&quot;1&quot;, @&quot;2&quot;, @&quot;3&quot;, @&quot;4&quot;, @&quot;6&quot;, @&quot;5&quot;] mutableCopy];
 
for (int i = 0; i &lt; ary.count - 1; i++) {
    
    for (int j = 0; j &lt; ary.count - i - 1; j++) {
        
        if ([ary[j] integerValue] &lt; [ary[j + 1] integerValue]) {
            
            [ary exchangeObjectAtIndex:j withObjectAtIndex:j + 1];
            
        }
        
    }
    
}
 
NSLog(@&quot;%@&quot;, ary);
</code></pre>
<h3><a id="30%E7%AE%80%E8%BF%B0%E5%AF%B9-uiview-uiwindow%E5%92%8Ccalayer%E7%9A%84%E7%90%86%E8%A7%A3" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>30.简述对UIView.UIWindow和CALayer的理解.</h3>
<p>UIWindow是应用的窗口,继承于UIResponder.</p>
<p>UIView继承于UIView,是创建窗口中的一个视图,可以响应交互事件.一个程序只有一个主window,可以有多个window.</p>
<p>CALayer图层,一个view可有多个图层,不可以响应事件.</p>
<h3><a id="31%E5%86%99%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E4%BB%A3%E7%90%86%E5%8C%85%E6%8B%AC%E5%A3%B0%E6%98%8E%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>31.写一个完整的代理,包括声明,实现.</h3>
<p>代理:遵守协议的对象.</p>
<p>@class MyView;</p>
<p>第一步:指定协议:(协议名:类名+Delegate)</p>
<p>@protocol MyViewDelegate <NSObject></p>
<p>@required</p>
<p>-(void)changeViewBackgroudColor:(MyView *)view;</p>
<p>@optional</p>
<p>-(void)test;</p>
<p>@end</p>
<p>@interface MyView : UIView</p>
<p>第二步:指定代理</p>
<p>@property(nonatomic,assign)id<MyView> delegate;</p>
<p>@end</p>
<p>第三步:代理遵循协议.</p>
<p>第四步:代理实现协议里面的必须实现的方法和其他可选方法.</p>
<p>第五步:委托方通知代理开始执行方法.</p>
<h3><a id="32%E5%88%86%E6%9E%90-json-xml%E7%9A%84%E5%8C%BA%E5%88%AB%E5%BA%95%E5%B1%82%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>32.分析json.xml的区别,底层如何实现?</h3>
<p>Json:键值对.数据小,不复杂.便于解析,有框架支持,适合轻量级传输.作为数据包个数传输的时候效率更高.</p>
<p>xml:标签套内容.xml数据两较大,比较复杂.适合大数据量的传输.xml有丰富的编码工具,比如:Dom4j,JDom.解析方式有两种,一是通过文芳模型解析,另外一种遍历节点.</p>
<h3><a id="33-viewcontroller%E7%9A%84didreceivememorywarning%E6%98%AF%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A2%AB%E8%B0%83%E7%94%A8%E7%9A%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>33.ViewController的didReceiveMemoryWarning是在什么时候被调用的?</h3>
<p>1.当应用程序的内存使用接近系统的最大内存使用时,应用会向系统发送内存警告,这时候系统会调用方法向所有ViewController发送内存警告.</p>
<p>2.打开系统相机.</p>
<p>3.加载高清图片.</p>
<p>默认操作:把里面没有用的对象进行释放.</p>
<h3><a id="34%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>34.面向对象的三大特征,简单介绍.</h3>
<p>封装:代码模块化,方便以后调用.</p>
<p>继承:子类继承父类的所有方法和属性.</p>
<p>多态:父类指针指向子类对象.</p>
<h3><a id="35%E9%87%8D%E5%86%99%E4%B8%80%E4%B8%AA-nsstring%E7%B1%BB%E5%9E%8B%E7%9A%84-retain%E6%96%B9%E5%BC%8F%E5%A3%B0%E6%98%8Ename%E5%B1%9E%E6%80%A7%E7%9A%84setter%E5%92%8Cgetter%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>35.重写一个NSString类型的,retain方式声明name属性的setter和getter方法.</h3>
<p>属性的三大特性:语义特性,原子特性,读写特性.</p>
<p>同时重写setter和getter方法,@synchronizedname = _name,关联属性和实例变量.</p>
<ul>
<li>
<p>(void)setName:(NSString *)name{</p>
<p>if(_name != name){</p>
<pre class="line-numbers"><code class="language-plain_text">  [_name retain];
  
  [_name release];
  
  _name = name;
</code></pre>
<p>}</p>
</li>
</ul>
<p>}</p>
<ul>
<li>
<p>(NSString *)name{</p>
<p>return [[_name retain]autorelease];</p>
</li>
</ul>
<p>}</p>
<h3><a id="36%E7%AE%80%E8%BF%B0-notificationcenter-kvc-kvo-delegate%E5%B9%B6%E8%AF%B4%E6%98%8E%E5%AE%83%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>36.简述NotificationCenter.KVC,KVO,Delegate?并说明它们之间的区别?</h3>
<p>NotificationCenter:消息中心.消息通知.</p>
<p>KVC:利用键-值间接访问类中的某个属性.<br />
[self setValue:@&quot;123&quot; forKeyPath:@&quot;name&quot;];<br />
NSLog(@&quot;%@&quot;,[self valueForKeyPath:@&quot;name&quot;]);</p>
<p>KVO:利用键-路径间接访问类中的某个属性,也就是观察者模式(KVO+通知中心).基于KVC和通知中心,观察的是实例变量.</p>
<p>Delegate:用于多个类之间的传值.</p>
<h3><a id="37-what-is-lazy-loading" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>37.What is lazy loading?</h3>
<p>懒加载</p>
<h3><a id="38%E5%AF%B9-mvc%E7%9A%84%E7%90%86%E8%A7%A3%E5%A5%BD%E5%A4%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>38.对MVC的理解,好处?</h3>
<p>MVC:是一种架构.model:数据处理,view:视图显示,controller:逻辑控制,负责视图和模型之间的通信.</p>
<p>高类聚,低耦合,提高代码的复用性.</p>
<h3><a id="39%E7%9B%91%E6%B5%8B%E9%94%AE%E7%9B%98%E7%9A%84%E5%BC%B9%E5%87%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>39.监测键盘的弹出.</h3>
<p>通知.</p>
<p>[[NSNotificationCenter defaultCenter]addObserver:self   selector:@selector()  name:UIKeyboardWillShowNotification  object:nil];</p>
<h3><a id="40-5%E4%B8%AAios-sdk%E5%BA%93%E5%92%8C%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>40. 5个ios,sdk库和第三方库.</h3>
<p>系统库:UIKit框架:负责应用程序的图形及事件驱动的关键基础,如:用户界面管理,图形和窗口支持.</p>
<p>Mapkit框架:地图.</p>
<p>Message UI框架:电子邮件</p>
<p>AV Foundation框架:可用于音频播放.</p>
<p>OpenAL框架:用于播放,可播放高质,高性能的网络音频</p>
<p>Core Data框架:将数据存储在SQLite数据库.</p>
<p>Core Media框架:播放视频.</p>
<p>第三方:SDWebImage :简化图片处理</p>
<p>ShareSDK   分享</p>
<p>SVProgressHUD  轻量级菊花</p>
<p>AFNetworkin 方便网络开发</p>
<p>FreeStreamer 播放音频</p>
<h3><a id="41%E4%BB%8B%E7%BB%8D%E5%93%8D%E5%BA%94%E8%80%85%E9%93%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>41.介绍响应者链.</h3>
<p>当用户点击屏幕,能够产生响应的对象组成的链.</p>
<p>继承自NSResponder,响应者链能够中断.</p>
<h3><a id="42%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>42.传值方式:</h3>
<p>通知,单例,代理,属性,block.</p>
<h3><a id="43-nsstring-test-nsdata-alloc-init-test%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>43.NSString * test = [[NSData alloc] init],test在编译时和运行时分别是什么类型的对象?</h3>
<p>编译时是NSString,运行时是NSData.NSData</p>
<h3><a id="44-oc%E4%B8%AD%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%A4%E4%BA%92%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>44.OC中对象的交互是如何实现的?</h3>
<p>消息机制.</p>
<h3><a id="45%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%A4%E6%96%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%98%AF%E5%90%A6%E8%BF%98%E6%9C%89-png%E6%9C%89%E5%B0%B1%E5%88%A0%E9%99%A4" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>45.给定一个字符串,判断字符串中是否还有png,有就删除.</h3>
<p>stringContains，使用@&quot;&quot;直接替换实现删除</p>
<h3><a id="46%E7%9B%AE%E6%A0%87%E5%8A%A8%E4%BD%9C%E6%9C%BA%E5%88%B6" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>46.目标-动作机制.</h3>
<p>Target - action</p>
<h3><a id="47%E4%BB%80%E4%B9%88%E6%98%AF%E6%B2%99%E7%9B%92%E6%B2%99%E7%9B%92%E9%87%8C%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E6%96%87%E4%BB%B6%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E8%B7%AF%E5%BE%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>47.什么是沙盒?沙盒里包含哪些文件,如何获取文件路径.</h3>
<p>沙盒:程序可操作的磁盘空间,系统为之开辟.</p>
<p>包含了3个文件夹.</p>
<p>1.Documents:存放一些比较重要的文件,但是放入Documents中的文件不能过大.</p>
<p>2.Library :是一个资源库,存储一些不太重要的数据.里面包含了两个子文件夹,Caches文件夹,用于缓存,</p>
<p>Preferences文件夹,系统偏好设置,用户对应用程序的设置,如密码.perferences路径无法找到,只能通过NSUserDefaults.</p>
<p>如:[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask,YES) firstObject];</p>
<h3><a id="48%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B-xmpp" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>48.介绍一下XMPP?</h3>
<p>基于XML的点对点通讯协议,实现通讯功能.</p>
<p>优点:可以跨平台开发.</p>
<p>缺点:丢包,只能发文字(图片发送发的是链接).</p>
<h3><a id="49%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%A6%82%E4%BD%95%E7%9C%81%E7%94%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>49.应用程序如何省电?</h3>
<p>获取请求不能过频.优化算法.</p>
<h3><a id="50%E5%86%99%E4%B8%80%E4%B8%AA%E9%80%92%E5%BD%92%E6%96%B9%E6%B3%95%E8%AE%A1%E7%AE%97-n%E7%9A%84%E9%98%B6%E4%B9%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>50.写一个递归方法,计算n的阶乘.</h3>
<pre class="line-numbers"><code class="language-objectivec">-(NSInteger)digui:(NSInteger)i{
    
    if (i&gt;0) {
        
        return i*[self digui:(i-1)];
        
    }else{
        
        return 1;
        
    }
    
}
 
[[NSUserDefaults standardUserDefaults]setObject:@([self digui:3]) forKey:@&quot;value&quot;];
</code></pre>
<h3><a id="51-nsarray%E5%92%8Cnsmutablearray%E7%9A%84%E5%8C%BA%E5%88%AB%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E9%82%A3%E4%B8%AA%E6%9B%B4%E5%AE%89%E5%85%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>51.NSArray和NSMutableArray的区别?多线程下那个更安全.</h3>
<p>NSArray:不可变数组.</p>
<p>NSMutableArray:可变数组.</p>
<p>多线程下NSArray更安全.</p>
<h3><a id="52%E5%8F%96%E5%87%BA%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>52.取出一个数组中的重复元素.</h3>
<p>1.放进集</p>
<p>2.遍历删除</p>
<p>3.放进字典作为key,再取出key</p>
<h3><a id="54-iskindofclass-ismemberofclass%E4%BD%9C%E7%94%A8%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>54.isKindOfClass,isMemberOfClass作用分别是什么?</h3>
<p>isKindOfClass是某个类的实例或者子类的实例.</p>
<p>isMemberOfClass是某个类的实例</p>
<h3><a id="55%E8%AF%B7%E5%88%86%E5%88%AB%E5%86%99%E5%87%BA-sel-id%E7%9A%84%E6%84%8F%E6%80%9D" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>55.请分别写出SEL,id的意思?</h3>
<p>SEL:选择器.<br />
id:范类型<br />
OC中的对象就是C语言的指针.</p>
<h3><a id="56-iphone%E4%B8%8A%E8%83%BD%E8%A2%AB%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%A8%8B%E5%BA%8F%E6%98%AF%E4%BB%80%E4%B9%88" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>56.iPhone上,能被应用程序直接调用的系统程序是什么?</h3>
<p>能:相册,相机,通讯录,音乐.</p>
<p>不能:计算器,天气,日历,指南针.</p>
<h3><a id="57%E4%BB%A5-mm%E4%B8%BA%E6%89%A9%E5%B1%95%E5%90%8D%E7%9A%84%E6%96%87%E4%BB%B6%E9%87%8C%E5%8F%AF%E4%BB%A5%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E4%BB%A3%E7%A0%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>57.以.mm为扩展名的文件里,可以包含哪些代码?</h3>
<p>C++,C,OC</p>
<h3><a id="58%E8%AF%B4%E8%AF%B4%E5%90%8E%E5%8F%B0%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>58.说说后台如何运行程序.</h3>
<p>在plist配置Application doesnotruninbackground设置NO(默认就是NO)的前提下.</p>
<p>添加required background modes,值是App registersforlocation updates和App playsauto orstreams audio/videousingAirPlay</p>
<h3><a id="59-sizeof%E5%92%8Cstrlen%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>59.sizeof和strlen的区别和联系?</h3>
<p>sizeof:占用空间大小.<br />
strlen:字符串大小.</p>
<h3><a id="60-sprintf-strcpy-memcpy%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BD%BF%E7%94%A8%E4%B8%8A%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>60.sprintf,strcpy,memcpy的功能?使用上要注意哪些地方?</h3>
<p>sprintf:将某些类型转换成字符串类型<br />
strcpy:拷贝字符串,会越界,'/0'<br />
memcpy:拷贝内存</p>
<h3><a id="61%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E5%AE%9E%E7%8E%B0-strlen%E7%9A%84%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>61.写一个函数实现strlen的功能?</h3>
<p>intsl(const char*s)</p>
<p>{</p>
<pre class="line-numbers"><code class="language-plain_text">int length = 0;

while (*s!='') {
    
    s++;
    
    length++;
    
}

return length;
</code></pre>
<p>}</p>
<h3><a id="62%E5%86%99%E4%B8%80%E4%B8%AA%E4%BB%A3%E7%A0%81%E7%89%87%E5%AE%9E%E7%8E%B0%E8%BE%93%E5%85%A5%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2-20130322152830%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%AA-nsdate%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%93%E5%8D%B0%E8%AF%A5%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%87%BA-2013-03-11-15-28-32" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>62.写一个代码片实现输入一个字符串&quot;20130322152830&quot;,输出一个NSDate类型的对象,打印该对象输出2013-03-11 15:28:32</h3>
<p>NSString * str = @&quot;20130322152832&quot;;</p>
<p>NSDateFormatter * format = [[NSDateFormatter alloc]init];</p>
<p>format.dateFormat =@&quot;yyyyMMddHHmmss&quot;;//设置格式</p>
<p>NSLog(@&quot;%@&quot;,[[format dateFromString:str] dateByAddingTimeInterval:8<em>60</em>60]);</p>
<h3><a id="63%E7%94%A8%E5%8F%98%E9%87%8F-a%E5%86%99%E5%87%BA%E4%BB%A5%E4%B8%8B%E5%AE%9A%E4%B9%89" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>63.用变量a写出以下定义</h3>
<p>a、一个整型数inta = 10</p>
<p>b、一个指向整型数的指针int*p = 10</p>
<p>c、一个指向指针的指针，它指向的指针是指向一个整型数int**p =10</p>
<p>d、一个有10个整型数的数组inta[10]</p>
<p>e、一个有10个指针的数组，该指针是指向一个整型数的int*a[10]</p>
<p>f、一个指向有10个整型数数组的指针int*a = {1,2,3,4,5,6,7,8,9,10};</p>
<p>g、一个指向函数的指针，该函数有一个整型参数，并返回一个整型数</p>
<p>int *a(int  b){</p>
<pre class="line-numbers"><code class="language-plain_text">return b;
</code></pre>
<p>}</p>
<h3><a id="64-cocoa%E5%92%8Ccocoa-touch" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>64.cocoa和cocoa touch?</h3>
<p>cocoa包含Foundation和AppKit框架，可用于开发Mac OS X系统的应用程序</p>
<p>cocoa touch包含Foundation和UIKit框架，可用于开发iPhone OS系统的应用程序</p>
<p>Cocoa时Mac OS X的开发环境，cocoa Touch是Iphone OS的开发环境</p>
<h3><a id="65%E7%BD%91%E7%BB%9C%E4%BB%8E%E4%B8%8B%E5%BE%80%E4%B8%8A%E5%88%86%E4%B8%BA%E5%87%A0%E5%B1%82%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>65.网络从下往上分为几层？</h3>
<p>从下往上：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</p>
<p>IP协议对应网络层，TCP协议对应传输层，HTTP协议对应于应用层。</p>
<p>socket则是对TCP/IP协议的封装和应用。也可以说，TCP/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTTP是应用层协议，主要解决</p>
<h3><a id="66%E7%83%AD%E6%9B%B4%E6%96%B0%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>66.热更新几种实现方式</h3>
<p><a href="http://www.jianshu.com/p/8cec322531ae">http://www.jianshu.com/p/8cec322531ae</a></p>
<h3><a id="67%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>67.多线程的底层实现？</h3>
<p>线程：进程中一个特立独行的控制单元（路径）。多线程：一个进程至少有一个线程，即主线程。<br />
①、Mach是第一个以多线程方式处理任务的系统，因此多线程的底层实现机制就是基于Mach的线程。</p>
<p>②、开发中很少用到Mach级的线程，因为Mach级的线程没有提供多线程的基本特征，线程之间是独立的。</p>
<p>④、开发中实现多线程的方案：</p>
<p>NSThread、GCD、NSOperationQueue.NSOperation</p>
<h3><a id="68%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>68.线程之间怎么通信?</h3>
<p>①.performSelect:onThread:withObject:waitUntilDone:</p>
<p>②.NSMachPort</p>
<h3><a id="69%E7%BD%91%E7%BB%9C%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98%E4%B8%AD%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E7%9B%B8%E5%90%8C%E7%9A%84%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E9%87%8D%E5%A4%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E9%97%AE%E9%A2%98" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>69.网络图片问题中怎么解决一个相同的网络地址重复请求的问题.</h3>
<p>利用字典:图片地址为key,下载操作为value.value</p>
<h3><a id="70%E7%94%A8-nsoperation%E5%92%8Cnsoperationqueue%E5%A4%84%E7%90%86a-b-c%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%E8%A6%81%E6%B1%82%E6%89%A7%E8%A1%8C%E5%AE%8C-a-b%E5%90%8E%E6%89%8D%E8%83%BD%E6%89%A7%E8%A1%8C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>70.用NSOperation和NSOperationQueue处理A.B.C三个线程,要求执行完A.B后才能执行?</h3>
<p>创建队列<br />
NSOperationQueue * queue = [[NSOperationQueue alloc]init];</p>
<p>创建三个操作<br />
NSOperation * A = [NSBlockOperation blockOperationWithBlock:^{</p>
<pre class="line-numbers"><code class="language-plain_text">NSLog{@&quot;A&quot;};
</code></pre>
<p>}];</p>
<p>NSOperation * B = [NSBlockOperation blockOperationWithBlock:^{</p>
<pre class="line-numbers"><code class="language-plain_text">NSLog{@&quot;B&quot;};
</code></pre>
<p>}];</p>
<p>NSOperation * C = [NSBlockOperation blockOperationWithBlock:^{</p>
<pre class="line-numbers"><code class="language-plain_text">NSLog{@&quot;C&quot;};
</code></pre>
<p>}];</p>
<p>添加依赖<br />
[C addDependency:a];</p>
<p>[C addDependency:b];</p>
<p>执行操作<br />
[queue addOperation:a];</p>
<p>[queue addOperation:b];</p>
<p>[queue addOperation:c];</p>
<h3><a id="71-gcd%E5%86%85%E9%83%A8%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>71.GCD内部怎么实现的?</h3>
<p>①.iOS和OSX的核心是XNU内核, GCD是基于XNU内核实现的(是由苹果电脑发展起来的操作系统内核).</p>
<p>②.GCD的API全部在libdispatch库中.</p>
<p>③.GCD底层实现主要有Dispatch Queue(管理block)和Dispatch Source(处理事件).</p>
<h3><a id="72%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E4%BA%BA%E5%BC%80%E5%8F%91%E8%BF%9B%E8%A1%8C%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E6%A3%80%E6%9F%A5%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>72.怎么保证多人开发进行内存泄露检查。</h3>
<p>使用Analuze进行代码的静态分析，为避免麻烦，多人开发尽量使用ARC.</p>
<h3><a id="73%E3%80%81%E9%9D%9E%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%83%85%E5%86%B5%E4%B8%8B%E6%80%8E%E4%B9%88%E5%81%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>73、非自动内存管理情况下怎么做单例模式。</h3>
<p>创建一个单例对象的静态实例，并初始化为nil。</p>
<p>创建一个类的类工厂方法，当且仅当这个类的实例为nil时生成一个类的实例。</p>
<p>实现NScopying协议，覆盖allocWithZone：方法，确保用户在直接分配对象时，不会产生另一个对象。</p>
<p>覆盖release、autorelease、retain、retainCount方法，确保单例的状态。</p>
<h3><a id="74%E3%80%81%E5%AF%B9%E4%BA%8E%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%88%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%89%E9%BB%98%E8%AE%A4%E6%98%AFautorelease%E7%9A%84%EF%BC%8C%E6%89%80%E6%9C%89%E7%B1%BB%E6%96%B9%E6%B3%95%E9%83%BD%E4%BC%9A%E8%BF%99%E6%A0%B7%E5%90%97%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>74、对于类方法（静态方法）默认是autorelease的，所有类方法都会这样吗？</h3>
<p>①、系统自带的绝大数类方法返回的对象，都是经过autorelease.</p>
<h3><a id="75%E3%80%81block%E5%9C%A8arc%E4%B8%AD%E5%92%8Cmrc%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>75、block在ARC中和MRC中的方法有何区别？需要注意什么？</h3>
<p>①．对于没有引用外部变量的Block，无论在ARC还是MRC下，类型都是_NSGlobalBlock_,这种类型的block可以理解为一种全局的block,不需要考虑作用域的问题。同时，对它进行Copy和Retain操作也是无效的。</p>
<p>②．避免循环引用。</p>
<p>根据isa指针，block一共有3种类型的block</p>
<p>_NSConcreteGlobalBlock全局静态</p>
<p>_NSConcreteStackBlock保存在栈中，出函数作用域就销毁</p>
<p>_NSConcreteMallocBlock保存在堆中，retainCount == 0销毁</p>
<h3><a id="76%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E5%92%8C%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>76.什么情况下会发生内存泄露和内存溢出？</h3>
<p>当程序在申请内存后，无法释放已经申请的内存空间（例如一个对象或者变量在用完后没有释放，这个对象就一直占用着内存），一次内存泄露可以忽略，但如果泄露过多的话，就会造成内存溢出。</p>
<p>当程序在申请内存时，但存入了更大的数据，出现内存溢出。</p>
<h3><a id="77-nsarray-arraywithobject-id%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%E6%B7%BB%E5%8A%A0%E5%AF%B9%E8%B1%A1%E5%90%8E%EF%BC%8C%E9%9C%80%E8%A6%81%E5%AF%B9%E8%BF%99%E4%B8%AA%E6%95%B0%E7%BB%84%E8%BF%9B%E8%A1%8C%E9%87%8A%E6%94%BE%E6%93%8D%E4%BD%9C%E5%90%97%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>77.[NSArray arrayWithobject<id>]这个方法添加对象后，需要对这个数组进行释放操作吗？</h3>
<p>不需要，这个对象会被放到自动释放池中。</p>
<h3><a id="78%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E6%B1%A0%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>78.自动释放池如何实现？</h3>
<p>自动释放池以栈的形式实现，当你创建一个新的自动释放池时，它将被添加到栈顶，当一个对象收到发送autorelease消息时，它将添加到当前线程的处于栈顶的自动释放池中，当自动释放池被回收时，它们从栈中被删除并且会给池子里所有对象都做一次release操作。</p>
<h3><a id="79-kvo%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>79.KVO内部实现原理？</h3>
<p>①．KVO是基于runtime机制实现的。</p>
<p>②．当某个类的对象第一次被观察时，系统就会在运行期动态的创建该类的一个派生类，在这个派生类中重写基类中任何被观察属性的setter方法。</p>
<p>派生类在被重写setter方法中实现了真正的通知机制。（Person-&gt;NSKVONotification Person）</p>
<h3><a id="80%E8%83%BD%E5%90%A6%E6%8A%8A%E6%AF%94%E8%BE%83%E8%80%97%E6%97%B6%E7%9A%84%E6%93%8D%E4%BD%9C%E6%94%BE%E5%9C%A8-nsnotificationcenter%E4%B8%AD%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>80.能否把比较耗时的操作放在NSNotificationCenter中。</h3>
<p>如果在异步线程发出的通知，那么就可以把耗时操作放到NSNotificationCenter中<br />
如果在主线程发的通知，那么就不可以把耗时操作放到NSNotificationCenter中。</p>
<h3><a id="81-foundation%E5%AF%B9%E8%B1%A1%E4%B8%8Ecore-foundation%E5%AF%B9%E8%B1%A1%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>81.Foundation对象与Core Foundation对象有何区别？</h3>
<p>Foundation对象是OC的，Core Foundation对象是C对象。<br />
数据类型之间的转换：</p>
<p>ARC：_bridge_retained、_bridge_transfer</p>
<p>非ARC:_bridge</p>
<h3><a id="82%E3%80%81%E4%B8%8D%E7%94%A8%E7%AC%AC%E4%B8%89%E5%8F%98%E9%87%8F%EF%BC%8C%E4%BA%A4%E6%8D%A2ab%E7%9A%84%E5%80%BC%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>82、不用第三变量，交换AB的值。</h3>
<p>A=A+B</p>
<p>B=A-B</p>
<p>A=A-B</p>
<p>或者</p>
<p>A=A^B</p>
<p>B=A^B</p>
<p>A=A^B</p>
<h3><a id="83%E7%AE%80%E5%8D%95%E6%8F%8F%E8%BF%B0%E4%B8%8B%E5%AF%B9%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>83.简单描述下对单例模式设计的理解？</h3>
<p>节省内存资源，一个应用就一个对象。</p>
<h3><a id="84-runtime%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%9C%BA%E5%88%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%8C%E4%B8%80%E8%88%AC%E7%94%A8%E4%BA%8E%E5%B9%B2%E5%98%9B%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>84.runtime实现的机制是什么？怎么用，一般用于干嘛。</h3>
<p>运行时机制，runtime库里面包含了跟类、成员变量、方法相关的API，比如获取类里面的所有成员变量，为类动态添加成员变量、动态改变类的方法实现，为类动态添加新的方法等，需要导入&lt;objc/message.h&gt;&lt;objc/message.h&gt;</p>
<p>①．runtime,运行时机制，它是一套C语言库。</p>
<p>②．实际上我们编写的所有OC代码，最终都是转换成为了runtime库的东西，比如类转换成了runtime库里面的结构体等数据类型，方法转换成了runtime库里面的C语言函数，平时调方法都是转成了objc_msgSend函数（所以说OC有个消息发送机制）</p>
<p>③、因此，可以说runtime是OC的底层实现，是OC的幕后执行者。</p>
<p>④、有了runtime库，能做什么呢？可以获取类里面的所有成员变量、为类动态的添加成员变量、动态的改变类的方法实现、为类动态添加新的方法等等。</p>
<h3><a id="85%E6%98%AF%E5%90%A6%E4%BD%BF%E7%94%A8-core-text%E6%88%96%E8%80%85core-image%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>85.是否使用Core Text或者Core Image？</h3>
<p>Core Text</p>
<p>随意修改文本的样式</p>
<p>图文混排（纯C语言）</p>
<p>Core Image(滤镜处理)</p>
<p>能够调节图片的各种属性（对比度、色温、色差等）</p>
<h3><a id="86%E3%80%81nsnotification%E5%92%8Ckvo%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8%E9%80%9A%E7%9F%A5%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BA%94%E8%AF%A5%E4%BD%BF%E7%94%A8kvo%E4%BB%96%E4%BB%AC%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%89%E4%BD%95%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E6%9E%9C%E7%94%A8-protocol%E5%92%8Cdelegate%E6%9D%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD%E5%8F%AF%E8%83%BD%E5%90%97%EF%BC%9F%E5%8F%AF%E8%83%BD%E7%9A%84%E8%AF%9D%E6%9C%89%E4%BD%95%E9%97%AE%E9%A2%98%EF%BC%9F%E4%B8%8D%E5%8F%AF%E8%83%BD%E7%9A%84%E8%AF%9Dwhy%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>86、NSNotification和KVO的区别和用法是什么？什么时候应该使用通知，什么时候应该使用KVO,他们的实现有何区别？如果用protocol和delegate来实现类似的功能可能吗？可能的话有何问题？不可能的话why？</h3>
<p>通知比较灵活，一个通知能被多个对象接受，一个对象可以接受多个通知。</p>
<p>代理不交规范，但是代码较多（默认是一对一）</p>
<p>KVO性能不好（底层会产生新的类），只能监听某个对象属性的变化，不推荐使用。</p>
<h3><a id="87%E3%80%81block%E5%86%85%E9%83%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>87、block内部的实现原理。</h3>
<p>Objective-C是对C语言的扩展，block的实现是基于指针和函数指针。</p>
<h3><a id="88%E3%80%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E7%BC%93%E5%AD%98%E6%B1%A0%E6%BB%A1%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>88、怎么解决缓存池满的问题？</h3>
<p>iOS中不存在缓存池满的情况，通常在对象需要创建时才创建，比如UITableView中一般只会创建刚开始在屏幕中的cell，之后都是从缓存池里取，不会再创建新对象。</p>
<h3><a id="89%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8view%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%A0%E5%9C%A8%E5%BC%80%E5%8F%91%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9A%84%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>89、控制器View的生命周期及相关函数是什么？你在开发中是如何使用的？</h3>
<p>1、首先判断控制器是否有视图，如果没有就调用loadView方法创建：通过storyBoard或者代码。</p>
<p>2、随后调用viewDidLoad，可以进行下一步的初始化操作，只会被调用一次。</p>
<p>3、在视图显示之前调用viewWillAppear,该函数可以多次调用。</p>
<p>4、视图viewDidAppear</p>
<p>5、在布局变化前后，调用viewWill/DidLayoutSubViews处理相关信息。</p>
<h3><a id="90%E3%80%81%E6%9C%89%E4%BA%9B%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%AF%94%E8%BE%83%E6%85%A2%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F%E4%BD%A0%E6%98%AF%E6%80%8E%E4%B9%88%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD%E7%9A%84%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>90、有些图片加载比较慢怎么处理？你是怎么优化程序的性能的？</h3>
<p>①、图片下载放在异步线程。</p>
<p>②、图片下载过程使用占位图片。</p>
<p>③、如果图片比较大，可以使用多线程断点下载。</p>
<h3><a id="91-app%E9%9C%80%E8%A6%81%E5%8A%A0%E8%BD%BD%E5%A4%A7%E9%87%8F%E6%95%B0%E6%8D%AE%EF%BC%8C%E7%BB%99%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%BD%86%E6%98%AF%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%A1%E4%BD%8F%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>91.App需要加载大量数据，给服务器发送请求，但是服务器卡住了怎么办？</h3>
<p>设置请求超时，给用户提示请求超时，根据用户操作再次请求。</p>
<h3><a id="92%E3%80%81sdwebimage%E5%85%B7%E4%BD%93%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>92、SDWebImage具体如何实现？</h3>
<p>其实就是沙盒缓存机制，主要由三块组成：内存图片缓存，内存操作缓存，磁盘沙盒缓存。</p>
<p>①、利用NSOperationQueue和NSOperation下载图片，还使用了GCD（解析GIF图片）。</p>
<p>②、利用URL作为key，NSOperation作为value.</p>
<p>③、利用URL作为key，UIImage作为value</p>
<h3><a id="93%E3%80%81afnetworking%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>93、AFNetWorking实现原理。</h3>
<p>基于NSURL.采用block的方法处理请求，直接返回的是json、XML数据。AFN直接操作对象是AFHTTPClient,是一个实现了NSCoding和NSCopying协议的NSObject子类。AFGTTPClient是一个封装了一系列操作方法的工具类。AFN默认没有封装同步请求，如果开发者需要使用同步请求，需要重写相关的方法（getPath:parameters:failure），对AFHTTPRequestOperation进行同步处理。</p>
<h3><a id="94%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%8D%E5%BA%94%E9%93%BE%EF%BC%8C%E5%AE%83%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>94、什么是响应链，它是怎么工作的？</h3>
<p><a href="http://www.jianshu.com/p/9179e5d780c8">http:</a><a href="http://www.jianshu.com/p/9179e5d780c8">//www.jianshu.com/p/9179e5d780c8</a></p>
<h3><a id="95%E3%80%81ios%E7%9A%84%E6%B2%99%E7%9B%92%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9Fapp-bundle%E9%87%8C%E9%9D%A2%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>95、iOS的沙盒目录结构是怎样的？App Bundle里面都有什么？</h3>
<p>1.沙盒结构</p>
<p>Application：存放程序源文件，上架前经过数字签名，上架后不可修改<br />
Documents：常用目录，iCloud备份目录，存放数据,这里不能存缓存文件,否则上架不被通过<br />
Library<br />
Caches：存放体积大又不需要备份的数据,SDWebImage缓存路径就是这个<br />
Preference：设置目录，iCloud会备份设置信息<br />
tmp：存放临时文件，不会被备份，而且这个文件下的数据有可能随时被清除的可能</p>
<p>2.App Bundle里面有什么</p>
<p>Info.plist:此文件包含了应用程序的配置信息.系统依赖此文件以获取应用程序的相关信息<br />
可执行文件:此文件包含应用程序的入口和通过静态连接到应用程序target的代码<br />
资源文件:图片,声音文件一类的<br />
其他:可以嵌入定制的数据资源</p>
<p>iOS的签名机制大概是怎样的？</p>
<p>假设，我们有一个APP需要发布，为了防止中途篡改APP内容，保证APP的完整性，以及APP是由指定的私钥发的。首先，先将APP内容通过摘要算法，得到摘要，再用私钥对摘要进行加密得到密文，将源文本、密文、和私钥对应的公钥一并发布即可。那么如何验证呢？<br />
验证方首先查看公钥是否是私钥方的，然后用公钥对密文进行解密得到摘要，将APP用同样的摘要算法得到摘要，两个摘要进行比对，如果相等那么一切正常。这个过程只要有一步出问题就视为无效。<br />
iOS 7的多任务添加了哪两个新的API?各自的使用场景是什么？</p>
<p>后台获取（Background Fetch):后台获取使用场景是用户打开应用之前就使app有机会执行代码来获取数据，刷新UI。这样在用户打开应用的时候，最新的内容将已然呈现在用户眼前，而省去了所有的加载过程。<br />
推送唤醒（Remote Notifications):使用场景是使设备在接收到远端推送后让系统唤醒设备和我们的后台应用，并先执行一段代码来准备数据和UI，然后再提示用户有推送。这时用户如果解锁设备进入应用后将不会再有任何加载过程，新的内容将直接得到呈现。</p>
<h3><a id="96%E3%80%81uiscrollview%E5%A4%A7%E6%A6%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%8C%E5%AE%83%E6%98%AF%E5%A6%82%E4%BD%95%E6%8D%95%E6%8D%89%E3%80%81%E5%93%8D%E5%BA%94%E6%89%8B%E5%8A%BF%E7%9A%84%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>96、UIScrollView大概是如何实现的，它是如何捕捉、响应手势的？</h3>
<p>我对UIScrollView的理解是frame就是他的contentSize,bounds就是他的可视范围,通过改变bounds从而达到让用户误以为在滚动,以下是一个简单的UIScrollView实现</p>
<p>在头文件定义一个contentSize属性</p>
<pre class="line-numbers"><code class="language-objectivec">@interface MyScrollView : UIView
@property (nonatomic) CGSize contentSize;
@end
 
@implementationMyScrollView
- (instancetype)initWithFrame:(CGRect)frame{
    self = [super initWithFrame:frame];
    if (self == nil) {
        return nil;
    }
 
   //添加一个滑动手势
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(panGesture:)];
    [self addGestureRecognizer:pan];
   return self;
}
 
- (void)panGesture:(UIPanGestureRecognizer *)gestureRecognizer{
   
//改变bounds
    CGPoint translation = [gestureRecognizer translationInView:self];
    CGRect bounds = self.bounds;
    
    CGFloat newBoundsOriginX = bounds.origin.x - translation.x;
    CGFloat minBoundsOriginX = 0.0;
    CGFloat maxBoundsOriginX = self.contentSize.width - bounds.size.width;
    bounds.origin.x = fmax(minBoundsOriginX, fmin(newBoundsOriginX, maxBoundsOriginX));
    
    CGFloat newBoundsOriginY = bounds.origin.y - translation.y;
    CGFloat minBoundsOriginY = 0.0;
    CGFloat maxBoundsOriginY = self.contentSize.height - bounds.size.height;
    bounds.origin.y = fmax(minBoundsOriginY, fmin(newBoundsOriginY, maxBoundsOriginY));
    
    self.bounds = bounds;
    [gestureRecognizer setTranslation:CGPointZero inView:self];
}
</code></pre>
<p>第二个问题个人理解是解决手势冲突,对自己添加的手势进行捕获和响应</p>
<p>让UIScrollView遵守UIGestureRecognizerDelegate协议,实现这个方法,在这里方法里对添加的手势进行处理就可以解决冲突</p>
<ul>
<li>(BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer</li>
</ul>
<h3><a id="97%E3%80%81objective-c%E5%A6%82%E4%BD%95%E5%AF%B9%E5%B7%B2%E6%9C%89%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8C%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8A%9F%E8%83%BD%E4%BB%A3%E7%A0%81%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BC%BC%E8%AE%B0%E5%BD%95%E6%97%A5%E5%BF%97%E8%BF%99%E6%A0%B7%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>97、Objective-C如何对已有的方法，添加自己的功能代码以实现类似记录日志这样的功能？</h3>
<p>这题目主要考察的是runtime如何交换方法</p>
<p>先在分类中添加一个方法,注意不能重写系统方法,会覆盖</p>
<ul>
<li>(NSString *)myLog<br />
{<br />
这里写打印行号,什么方法,哪个类调用等等<br />
}</li>
</ul>
<p>然后交换方法</p>
<p>加载分类到内存的时候调用</p>
<ul>
<li>
<p>(void)load<br />
{<br />
获取imageWithName方法地址<br />
Method description = class_getClassMethod(self, @selector(description));</p>
<p>获取imageWithName方法地址<br />
Method myLog = class_getClassMethod(self, @selector(myLog));</p>
<p>交换方法地址，相当于交换实现方式<br />
method_exchangeImplementations(description, myLog);<br />
}</p>
</li>
</ul>
<h3><a id="98%E3%80%81-load%E5%92%8C-initialize%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>98、+load和+initialize的区别是什么？</h3>
<p>+(void)load;<br />
当类对象被引入项目时, runtime会向每一个类对象发送load消息<br />
load方法会在每一个类甚至分类被引入时仅调用一次,调用的顺序：父类优先于子类,子类优先于分类<br />
load方法不会被类自动继承<br />
+(void)initialize;<br />
也是在第一次使用这个类的时候会调用这个方法</p>
<h3><a id="99%E3%80%81%E5%A6%82%E4%BD%95%E8%AE%A9category%E6%94%AF%E6%8C%81%E5%B1%9E%E6%80%A7%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>99、如何让Category支持属性？</h3>
<p>使用runtime可以实现</p>
<p>头文件</p>
<p>@interface NSObject (test)</p>
<p>@property (nonatomic, copy) NSString *name;</p>
<p>@end</p>
<p>.m文件</p>
<p>@implementation NSObject (test)<br />
定义关联的key<br />
static const char*key =&quot;name&quot;;</p>
<ul>
<li>(NSString *)name<br />
{<br />
根据关联的key，获取关联的值。<br />
return objc_getAssociatedObject(self, key);<br />
}</li>
<li>(void)setName:(NSString *)name<br />
{<br />
第一个参数：给哪个对象添加关联<br />
第二个参数：关联的key，通过这个key获取<br />
第三个参数：关联的value<br />
第四个参数:关联的策略<br />
objc_setAssociatedObject(self, key, name, OBJC_ASSOCIATION_RETAIN_NONATOMIC);<br />
}</li>
</ul>
<h3><a id="100%E3%80%81nsoperation%E7%9B%B8%E6%AF%94%E4%BA%8Egcd%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>100、NSOperation相比于GCD有哪些优势？</h3>
<p>提供了在GCD中不那么容易复制的有用特性。<br />
可以很方便的取消一个NSOperation的执行<br />
可以更容易的添加任务的依赖关系<br />
提供了任务的状态：isExecuteing, isFinished.</p>
<h3><a id="101%E3%80%81strong-weak-unsafe-unretained%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>101、strong / weak / unsafe_unretained的区别？</h3>
<p>weak只能修饰OC对象,使用weak不会使计数器加1,对象销毁时修饰的对象会指向nil,strong等价与retain,能使计数器加1,且不能用来修饰数据类型</p>
<p>unsafe_unretained等价与assign,可以用来修饰数据类型和OC对象,但是不会使计数器加1,且对象销毁时也不会将对象指向nil,容易造成野指针错误</p>
<h3><a id="102%E3%80%81%E5%A6%82%E4%BD%95%E4%B8%BAclass%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E5%AF%B9%E5%A4%96%E5%8F%AA%E8%AF%BB%E5%AF%B9%E5%86%85%E5%8F%AF%E8%AF%BB%E5%86%99%E7%9A%84%E5%B1%9E%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>102、如何为Class定义一个对外只读对内可读写的属性?</h3>
<p>在头文件中将属性定义为readonly,在.m文件中将属性重新定义为readwrite</p>
<h3><a id="103%E3%80%81objective-c%E4%B8%AD%EF%BC%8Cmeta-class%E6%8C%87%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>103、Objective-C中，meta-class指的是什么？</h3>
<p>meta-class是Class对象的类,为这个Class类存储类方法,当一个类发送消息时,就去那个类对应的meta-class中查找那个消息,每个Class都有不同的meta-class,所有的meta-class都使用基类的meta-class(假如类继承NSObject,那么他所对应的meta-class也是NSObject)作为他们的类</p>
<h3><a id="104%E3%80%81uiview%E5%92%8Ccalayer%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>104、UIView和CALayer之间的关系？</h3>
<p>UIView显示在屏幕上归功于CALayer，通过调用drawRect方法来渲染自身的内容，调节CALayer属性可以调整UIView的外观，UIView继承自UIResponder，CALayer不可以响应用户事件<br />
UIView是iOS系统中界面元素的基础，所有的界面元素都继承自它。它内部是由Core Animation来实现的，它真正的绘图部分，是由一个叫CALayer(Core Animation Layer)的类来管理。UIView本身，更像是一个CALayer的管理器，访问它的根绘图和坐标有关的属性，如frame，bounds等，实际上内部都是访问它所在CALayer的相关属性<br />
UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UIView使用不同的CALayer来显示</p>
<h3><a id="105%E3%80%81-uiview-animatewithduration-animations-completion%E5%86%85%E9%83%A8%E5%A4%A7%E6%A6%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>105、+[UIView animateWithDuration:animations:completion:]内部大概是如何实现的？</h3>
<p>animateWithDuration:这就等于创建一个定时器<br />
animations:这是创建定时器需要实现的SEL<br />
completion:是定时器结束以后的一个回调block</p>
<p>以上只是自己的理解,不一定正确,有对这个有研究的朋友请告知下</p>
<h3><a id="106%E3%80%81%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E5%8F%91%E7%94%9F%E3%80%8C%E9%9A%90%E5%BC%8F%E5%8A%A8%E7%94%BB%E3%80%8D%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>106、什么时候会发生「隐式动画」？</h3>
<p>当改变CALayer的一个可做动画的属性，它并不能立刻在屏幕上体现出来.相反，它是从先前的值平滑过渡到新的值。这一切都是默认的行为，你不需要做额外的操作,这就是隐式动画</p>
<h3><a id="107%E3%80%81%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>107、如何处理异步的网络请求？</h3>
<p>异步请求：会单独开一个线程去处理网络请求，主线程依然处于可交互状态,程序运行流畅</p>
<pre class="line-numbers"><code class="language-objectivec">//POST请求
NSString *urlString = @&quot;www.baidu.com&quot;;
//创建url对象
NSURL *url = [NSURL URLWithString:urlString];
//创建请求
NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:url cachePolicy:NSURLRequestReloadIgnoringLocalCacheData timeoutInterval:10];
//创建参数字符串对象
NSString *parmStr = [NSString stringWithFormat:@&quot;参数&quot;];
//将字符串转换为NSData对象
NSData *data = [parmStr dataUsingEncoding:NSUTF8StringEncoding];
[request setHTTPBody:data];
[request setHTTPMethod:@&quot;POST&quot;];
//创建异步连接
[NSURLConnection connectionWithRequest:request delegate:self];
</code></pre>
<p>然后实现代理方法</p>
<pre class="line-numbers"><code class="language-objectivec">//服务器接收到请求时
- (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
{
}
//当收到服务器返回的数据时触发,返回的可能是资源片段
- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
{
}
//当服务器返回所有数据时触发,数据返回完毕
- (void)connectionDidFinishLoading:(NSURLConnection *)connection
{
}
//请求数据失败时触发
- (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error
{
    NSLog(@&quot;%s&quot;, __FUNCTION__);
}
</code></pre>
<h3><a id="108%E3%80%81frame%E5%92%8Cbounds%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>108、frame和bounds的区别是什么？</h3>
<p>frame相对于父视图,是父视图坐标系下的位置和大小。bounds相对于自身,是自身坐标系下的位置和大小。<br />
frame以父控件的左上角为坐标原点，bounds以自身的左上角为坐标原点</p>
<h3><a id="109%E3%80%81%E5%A6%82%E4%BD%95%E6%8A%8A%E4%B8%80%E5%BC%A0%E5%A4%A7%E5%9B%BE%E7%BC%A9%E5%B0%8F%E4%B8%BA14%E5%A4%A7%E5%B0%8F%E7%9A%84%E7%BC%A9%E7%95%A5%E5%9B%BE%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>109、如何把一张大图缩小为1/4大小的缩略图？</h3>
<p>let data = UIImageJPEGRepresentation(image, 0.25)</p>
<p>已使用 Microsoft OneNote 2016 创建。</p>

        </article>
        <div class="comments-wrap">
          <div class="share-comments">
            
            <script src="https://utteranc.es/client.js"
                    repo="Apolla/gtalk"
                    issue-term="title"
                    theme="github-dark"
                    crossorigin="anonymous"
                    id="github-comment"
                    async>
            </script>
             
            

            

            
          </div>
        </div><!-- end comments wrap -->
      </div>
      <div class="column">
         <div class="card">
  <header class="card-header">
    <p class="card-header-title">
      <i class="fa fa-commenting" aria-hidden="true"></i>&nbsp;&nbsp;
      <span class="tran-notice">Notice</span> 
    </p>
  </header>
  <div class="card-content site-notice">
    <div class="content"> 
        
    </div>
  </div>                    
</div>
<div class="card">
  <header class="card-header">
    <p class="card-header-title">
      <i class="fa fa-folder-open" aria-hidden="true"></i>&nbsp;&nbsp;
      <span class="tran-site-categories">Categories</span> 
    </p>
  </header>
  <div class="card-content site-categories">
    <div class="content"> 
      <ul>
      
        <li><a href="%E7%BB%84%E4%BB%B6%E5%8C%96.html">组件化</a>
          
          
          
        </li> 
      
        <li><a href="%E7%A2%8E%E7%89%87%E8%8A%9D%E5%A3%AB%E6%94%B6%E8%97%8F.html">碎片芝士收藏</a>
          
          
          
        </li> 
      
        <li><a href="%E7%9B%B4%E6%92%AD.html">直播</a>
          
          
          
        </li> 
      
        <li><a href="coreBluetooth.html">coreBluetooth</a>
          
          
          
        </li> 
      
        <li><a href="%E4%B8%80%E9%98%85%E9%98%85%E8%AF%BB.html">一阅阅读</a>
          
          
          
        </li> 
      
        <li><a href="SwiftUI.html">SwiftUI</a>
          
          
          
        </li> 
      
        <li><a href="%E8%91%B5%E8%8A%B1%E5%AE%9D%E5%85%B8.html">葵花宝典</a>
          
          
          
        </li> 
      
      </ul>
    </div>
  </div>                    
</div>
<div class="card">
  <header class="card-header">
    <p class="card-header-title">
      <i class="fa fa-tags" aria-hidden="true"></i>&nbsp;&nbsp;
      <span class="tran-site-tags">Tags</span> 
    </p>
  </header>
  <div class="card-content site-tags">
    <div class="content">
      <div class="tags">
      
      </div>
    </div>
  </div>
</div>

      </div>
    </div><!-- end columns -->
  </div><!-- end container -->
</section>



    <footer class="footer">
    <div id="plt"></div>
    <div class="content has-text-centered">
      <p>
        Copyright &copy; 2019
        <span id="tran-author" class="tran-author">Author: </span><a target="_blank" href="http://apolla.cc">宋明</a>,&nbsp; 
        <span class="tran-theme">Theme: </span><a target="_blank" href="https://github.com/AlanAlbert/atheme">Atheme</a> (Based on BulmaCSS).
      </p>
    </div>
  </footer>



  













<script src="asset/prism.js"></script>

<script type="text/javascript">
  var imgApi = "https://source.unsplash.com/random/1024x";
  var imgContainers = document.getElementsByClassName('random-img');
  for (var i = 0; i <= imgContainers.length - 1; i++) {
    // https://picsum.photos/1024/
    var img = document.createElement('img');
    img.src = imgApi + (400 + i);
    imgContainers[i].appendChild(img);
  }
</script>


<script type="text/javascript">
  
    
    var modelJson = 'asset/cat/black/hijiki.model.json';
    var pluginRootPath = 'asset/cat/black';
    var pluginModelPath = 'asset/cat/black';
    
  
  

  var config = {
    pluginRootPath: pluginRootPath,
    pluginJsPath: "lib/",
    pluginModelPath: pluginModelPath,
    tagMode:false,
    debug:false,
    model: {
      jsonPath: modelJson,  // xxx.model.json 的路径
    },
    display: {
      width: 325,           // canvas的宽度
      height: 300,          // canvas的高度
      position: 'right',    // 显示位置：左或右
      hOffset: -75,         // canvas水平偏移
      vOffset: 0,           // canvas垂直偏移
    },
    dialog:{
      enable: true
    },
    mobile: {
      show: false,         // 是否在移动设备上显示
    },
    react: {
      opacity: 1,         // 透明度
    },
    log: false,
  };
  L2Dwidget.init(config);
</script>


  
    




  </body>
</html>
